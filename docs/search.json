[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmation avec Stata",
    "section": "",
    "text": "Présentation de la formation\n\n\n\n\n\n\nSeptembre 2023\n\n\n\nLa fin de la mise à jour approche, avec le début du dernier chapitre. Penser à vous reporter sur la formation dédiée au graphiques, ces éléments ayant été retiré de ce support (encore quelques élement dans le chapitre 4).\n\n\n\nCe support n’intéressera peut-être pas les plus aguerri.e.s à Stata…. quoique. On trouve toujours, après des années pratique, de nouvelles commandes qui facilitent vraiment les choses (sencode, fre, tabm,…., commandes du package gtools). Un introduction aux frames introduites avec la version 16 et qui revisitent les fusions de bases, mais qui ne semble pas encore très utilisé, a été ajouté.\nLa formation est téléchargeable en format pdf. Pour accéder à cette version aller sur l’icône pdf à droite de la barre de navigation.\nSi la grande majorité des éléments inclus à ce support sont classiques, on peut se reporter sur l’accueil principal pour trouver des fiches, encore en nombre limités, sur des fonctions que j’ai programmé ou sur des éléments de mise à jour du logiciel.\nMaj de la formation (de la plus ancienne à la plus récente):\n\n28/07/22 : Les variables. Chapitre 5 [todo: faire un topo sur les formats date avant fin 2023]\n07/10/22 : Introduction. Chapitre 1\n07/10/22 : L’environnement. Chapitre 2\n22/02/23 : Le langage Stata. Chapitre 3\n22/02/23 : Les bases de données. Chapitre 4 [introduction aux frame introduites avec la v16]\n09/08/23 : Manipulation bases de données (fusion, transpositions…). Chapitre 6\n\n\nLes programmes des exemples traités dans les chapitres (à partir du troisième) sont téléchargeables:\n\nChapitre3\nChapitre4\nChapitre5\nChapitre6\nChapitre7\n\n\n\nSupport réalisé avec Posit-Rstudio avec l’outil d’édition Quarto.\nVersion Stata: 18-SE"
  },
  {
    "objectID": "chapitre1.html#historique-de-stata",
    "href": "chapitre1.html#historique-de-stata",
    "title": "1  Présentation de Stata",
    "section": "1.1 Historique de Stata",
    "text": "1.1 Historique de Stata\nL’entreprise Stata Corp Lp a été fondée par William Gould. Il est toujours à la tête de l’entreprise.\n\nPremière version (sous MS Dos) en janvier 1985.\n\nPremière version Windows en 1995 (Stata 4).\n\nLa version la plus récente est la 17 [printemps 2021].\nLe rythme de changement de version est de 2 ans. La version 18 devrait donc sortir au printemps 2023. Attention tout de même, il s’agit plutôt de grosses mises à jour, dont l’acquisition systématique s’avère généralement dispensable.\n\n\n\n\n\n\n\nVersion 18 et 17\n\n\n\nVersion 18\n\nUne autosave des programmes (enfin)\nNouveau format .dtas pour enregistrer une liste de frames générées dans un programme\nGraphiques (se reporter à la formation graphique):\n\nNouvelle palette qualitative (enfin)\nNouveau thème par défaut (enfin)\nUne nouvelle option colorvar (cf fill, color dans R ou python) qui permet d’empiler automatiquement ou presque plusieurs objet graphiques (autrefois un objet par valeur d’une condition)\n\n\nVersion 17\nUne présentation a été faite il y a plus d’un an [Lien].\nEn résumé pour cette 17ème version:\n\nAmélioration de la vitesse d’exécution (je confirme)\nSuite collect pour gérer et générer les outputs des commandes statistiques. Rapidement testé pour des régressions. C’est plutôt pas mal même si comme d’habitude avec Stata “qui se raccroche aux branche”, cela peut vite toutner à l’usine à gaz [rapide présentation]"
  },
  {
    "objectID": "chapitre1.html#stata-à-lined",
    "href": "chapitre1.html#stata-à-lined",
    "title": "1  Présentation de Stata",
    "section": "1.2 Stata à l’Ined",
    "text": "1.2 Stata à l’Ined\n\nVersion 18 Window SE en cours de déploiement, la version 17 Windows SE a été déployée au printemps 2022.\n\nVersion 17 SE sous Linux (serveur margaux).\n\nPetit rappel pour l’Ined: Quel que soit le logiciel choisi sous environnement Windows (SAS v9.4 ou Stata) vous avez accès à une version de l’autre application sous Linux via le serveur Margaux (SAS Studio ou STATA v17 SE).\nVersion SE: Standard Edition\n\nNombre d’observations: 2.14 milliards\nNombre de variables dans les bases: 32 767\nNombre de variables RHS (limite nombre de colonnes des matrices: 10998)\n\nIl existe également des versions dites MP (Multiple Process), dont la plus puissante gère 120000 variables et 20 milliards d’observations)."
  },
  {
    "objectID": "chapitre1.html#les-ressources",
    "href": "chapitre1.html#les-ressources",
    "title": "1  Présentation de Stata",
    "section": "1.3 Les ressources",
    "text": "1.3 Les ressources\n\n1.3.1 Les ressources externes\n\nLes manuels édités par STATA. Certains, anciennement à la bibliothèque de l’Ined, sont disponibles au GED [http://www.stata.com/bookstore/books-on-stata]\n*Stata Journal, la revue trimestrielle éditée par Stata [http://www.stata-journal.com]. Depuis 2015 accès total aux versions PDF (via portail GED maintenant). L’accès et le sommaire des 4 derniers numéro est disponible ici: Lien\nUne chaîne Youtube [http://www.youtube.com/user/statacorp/videos?view=0] qui propose des tutoriels via les manipulations par les boites de dialogue.\nUn forum particulièrement actif (https://www.statalist.org/)\n\n\n\n1.3.2 Les ressources internes\n\nLe manuel de Stata est directement intégré au logiciel. Pour y accéder à partir du menu : help =&gt; PDF documentation. Il est vraiment de très bonne qualité et reconnu comme tel.\nPour une instruction, on peut obtenir son aide en tapant dans la fenêtre command de l’environnement principal help nom_commande.\n\nPour les commandes internes, un lien permet d’accéder à l’entrée du manuel officiel.\n\nDans les fenêtres de dialogue, on peut accéder directement au fichier d’aide en cliquant sur le point d’interrogation.\n\n\n\n\n\nUtiliser l'aide interne\n\nhelp generate\n\n\nL’animation suivante n’est bien évidemment pas disponible en format pdf\n\n\n\n\n\nL’aide comprend généralement:\n\nLe nom de la commande\nLe lien vers l’entrée du manuel si commande officielle. Pour les commandes externes, un lien vers le site support peut-être proposé.\nLa description de la syntaxe\nLe détail des options\nDes exemples avec éventuellement une exécution directe (voir avec help tw)\nLes informations sauvegardées temporairement (jusqu’à l’exécution d’une autre commande) =&gt; stored results. C’est informations peuvent être des valeurs, des matrices, qui pourront être réutilisés dans la suite d’un programme (voir le chapitre sur la syntaxe).\nL’instruction findit nom_command permet d’obtenir la liste de toutes les ressources disponibles d’une commande, internes ou externes. Exemple: findit fitstat\n\n\n\n\n\n\n\nWarning: compatibilité entre les versions\n\n\n\nDes problèmes de compatibilité entre les versions de Stata se sont posés. Cela affecte la lecture des bases entre les différentes versions du logiciel. Le dernier cas en date est maintenant assez ancien (version 14).\nVersion 14: refonte total du système d’encodage vers le standard UTF8.\nLes versions inférieures de Stata ne peuvent pas ouvrir les bases au format actuel, qui doivent être enregistrées avec une commande particulière (saveold) sous Stata 14 à 17. Les accents ne sont pas lu après cette conversion, et ce qui nécessite d’exécuter un programme pour les convertir (au secours!!!!).\nA l’Ined, depuis le déploiement de la version 14 et le passage à la version 15 Linux, il n’y a plus de problème.\nOn peut également regréter que Stata n’offre pas un certain niveau de rétrocompatibilité avec, au moins avec la version précédente. Par exemple la nouvelle palette de couleurs et le nouveau thème pour les graphiques par défaut, aurait pu être proposés comme maj aux versions 16 ou 17."
  },
  {
    "objectID": "chapitre1.html#les-users-packages",
    "href": "chapitre1.html#les-users-packages",
    "title": "1  Présentation de Stata",
    "section": "1.4 Les users packages",
    "text": "1.4 Les users packages\nStata fonctionne avec un système hybride de commandes officielles ou usines et de commandes externes (idem R, Python…).\nCommandes externes ou user package:\n\nIl s’agit d’instructions créees par les utilisateurs\nCes instructions couvrent le data management et l’analyse statistique (descriptive, modélisation, graphiques)\nMême syntaxe que les instructions officielles\nLa liste (triée par année) de ces instructions se trouve à cette adresse [http://ideas.repec.org/s/boc/bocode.html]. Elle n’est pas exhaustive, seulement celles sur le dépôt de Stata. Les dépôts dans les gits, en particulier Github tendent à se développer. Tout comme R, les dépôts usines ne sont pas forcément les plus à jour.\n\nInstallation directe d’une commande externe\nPour télécharger un package, on peut utiliser la ligne de commande:\n\n\n\nInstallation d'une commande\n\nssc install nom_commande, replace\n\n\n\nIl est possible d’installer un package après avoir consulté les fichiers avec la commande findit.\nOn peut également consulter le fichier d’aide de lacommande avant de l’installer.\n\nLes programmes des packages externes se trouvent dans un répertoire spécifique plus/ado, souvent installé dans la racine du lecteur C:. On peut déplacer ce répertoire, et c’est conseillé si on dispose, comme à l’Ined, d’une sauvergarde régulière sur un autre lecteur via un serveur. On peut vérifier la localisation de ce répertoire avec la commande sysdir, et plus généralement la localisation des répertoires d’utilisation de Stata.\n\nsysdir\n\n   STATA:  C:\\PROGRA~1\\Stata17\\\n    BASE:  C:\\PROGRA~1\\Stata17\\ado\\base\\\n    SITE:  C:\\PROGRA~1\\Stata17\\ado\\site\\\n    PLUS:  D:\\D\\ado\\plus\\\nPERSONAL:  D:\\D\\ado\\personal\\\nOLDPLACE:  c:\\ado\\\n\n\nExercice\nOuvrir la base d’exemple auto\nDans la fenêtre Command: sysuse auto, clear\n\n[1] Accéder à l’aide (pdf) de l’instruction tabulate. Faire un tableau croisé entre la variable foreign et rep78.\n[2] Installer le package externe findname, exécuter findname t* et chercher les variables de type chaine de caractère (string).\n\n\n\n\n\n\n\nprofile.do\n\n\n\nAttention: Avec la version 18, la technique permettant avec un profile.do de récupérer une sauvegarde d’un programme n’a plus aucune utilité, Stata ayant (enfin) une autosave des programmes.\nPour en savoir plus sur le paramétrage des sessions avec un fichier profile.do [Lien]"
  },
  {
    "objectID": "chapitre2.html#les-principaux-types-de-fichier",
    "href": "chapitre2.html#les-principaux-types-de-fichier",
    "title": "2  L’environnement",
    "section": "2.1 Les (principaux) types de fichier",
    "text": "2.1 Les (principaux) types de fichier\n\nLes bases de données: .dta\nL’éditeur de programme : .do (.ado pour la programmation de commandes)\nLe log de session : .smcl ou .log (conversion possible en .txt, .doc ou .pdf)\nLes graphiques : .gph (+ enregistrement en format image: png, jpg, svf…)\nLes fichiers d’aides: .sthlp"
  },
  {
    "objectID": "chapitre2.html#où-passer-ses-instructions",
    "href": "chapitre2.html#où-passer-ses-instructions",
    "title": "2  L’environnement",
    "section": "2.2 Où passer ses instructions ?",
    "text": "2.2 Où passer ses instructions ?\n\nDans l’éditeur de programme (.do ou .ado ou écritue d’un fichier d’aide)\nDans la fenêtre “Command” de l’environnement principal\nPar les menus (ouverture d’une boîte de dialogue). On récupéré la syntaxe de l’instruction directement dans l’interface principale, et par copier-coller dans l’éditeur de programme. Plutôt pratique."
  },
  {
    "objectID": "chapitre2.html#linterface-principale",
    "href": "chapitre2.html#linterface-principale",
    "title": "2  L’environnement",
    "section": "2.3 L’interface principale",
    "text": "2.3 L’interface principale\n\n\n\n\n\nBoite output\nAffiche les commandes exécutées et les résultats\nBoite review\n\nC’est un log de toutes les instructions passées par la fenêtre command\nEn cliquant de dessus, l’instruction est de nouveau affichée dans la fenêtre command\nAvec un clic-droit on peut copier, supprimer les instructions. Les instructions en rouge déclarent celles avec une erreur\nLes instructions passée par l’éditeur de programme ne sont reportée\n\nBoite variables\n\nListe les variables présentent dans la base chargée avec éventuellement leur label\nEn cliquant dessus, là ou les variables sont affichées dans la fenêtre command\nAvec un cliqu-droit, une ou plusieurs variables peuvent être copiées, conservées ou supprimées\n\nBoite properties\n\nPour les variables affiche leurs propriétés: nom, label, format, type….\nSi le cadenat est délocké, on peut modifier ces propriétés (voir variable manager). Le code qui exécute la modification est affichée dans la fenêtre command et la boîte review"
  },
  {
    "objectID": "chapitre2.html#menus-et-raccourcis",
    "href": "chapitre2.html#menus-et-raccourcis",
    "title": "2  L’environnement",
    "section": "2.4 Menus et raccourcis",
    "text": "2.4 Menus et raccourcis\n\n\n\n\n\nMenus (boîtes de dialogue)\n\nFile: gestion des fichiers =&gt; création, ouverture, import/export…\nEdit: utile pour la modification des préférences (couleurs interface, thèmes graphique)\nData: manipulation des données\nGraphics: création de graphiques\nStatistics: instructions stat: descriptifs, modèles\nUser: accès à vos boîtes de dialogue programmée en java\nWindows: activation des boîtes de l’interface principale\nhelp: infos sur le logiciel et accès à des ressources (internes et liens)\n On peut accéder directement à une boîte de dialogue avec la commande db nom_commande\n\n\n\n\nSyntaxe\n\ndb logit\n\n\nRaccourcis (dans l’ordre de gauche à droite)\n\nOuverture d’un fichier\nEnregistrement de la base de données active\nImpression de la fenêtre output\nOuverture d’un log\nOuverture de la fenêtre d’aide\nOuverture de l’éditeur de graphique (modification d’un graphique créé)\nCréation ou ouverture de l’éditeur de programme (.do .ado . sthlp)\nOuvre la base de données active en mode édition\nOuvre la base de données active en mode lecture\nOuvre le variable manager\nDéblocage du défilement de l’output pendant l’exécution\nArrête l’exécution d’un programme"
  },
  {
    "objectID": "chapitre2.html#léditeur-de-programme",
    "href": "chapitre2.html#léditeur-de-programme",
    "title": "2  L’environnement",
    "section": "2.5 L’éditeur de programme",
    "text": "2.5 L’éditeur de programme\n\n\n\n\n\n\n2.5.1 Soumettre un programme ou un bloc de programme\n\nOn ne sélectionne aucune ligne: tout le programme est exécuté\nOn sélectionne une partie du programme: seul le bloc est exécuté\n\n\n\n\n\n\n\nexecute (do): les commandes et les résultats sont affichés dans l’output de l’interface principale\nexecute quietly (run): les commandes et les résultats ne sont pas affichés dans l’output de l’interface principale\n\n\n\n\n\n\n\ndo et run dans un programme\n\n\n\nOn peut exécuter un ou plusieurs programme enregistré dans un programme\n\ndo \"path/nom_prog.do\"  // avec affichage de l'output\nrun \"path/nom_prog.do\" // sans affichage de l'output\n\n\n\n\n\n2.5.2 delimiter\nPar défaut une ligne = une instruction (#delimit cr).\nStata ne comprend pas la deuxième ligne de:\n\nkeep  X1 X2 \n      X3 X4\n\nOn peut contourner cela dans un programme pour écrire des instructions longue sur plusieurs lignes avec l’instruction #delimit ;\n\n#delimit ;\nkeep  X1 X2  \n      X3 X4;\n      \ntabulate X1;\n\nLe délimiteur s’appliquera tant qu’on ne repasse pas à #delimit cr\n\n#delimit ;\nkeep  X1 X2  \n      X3 X4;\n      \n#delimit cr      \ntabulate X1\n\nLe délimiteur ; est sourtout utilisé pour les graphiques qui peuvent âtre assez gourmants en options (je le conseille).\nLa solution la plus utilisée est /// à la fin d’une ligne, à l’exception de la dernière de la commande\n\nkeep  X1 X2 /// \n      X3    /// \n      X4\n\ntabulate X1\n\n\n\n2.5.3 Les commentaires\nSi le commentaire est sur une seule ligne\n\n* Commentaire\n\nSi le commentaire est sur une ligne et suit une instruction\n\ninstruction  // Commentaire \n\nSi le commentaire est sur plusieurs lignes\n\n/* commentaire 1\n   commentaire 2 */\n\n\n\n\n\n\n\nPas d’autosave des programmes…jusqu’à Stata 18\n\n\n\nEnfin, enfin, enfin….\nDepuis avril 2023 une autosave des programmes a été implémentée au logiciel. Pour faire court:\n\nPenser à ce que le fichier soit déjàsauvegardé.\nOn peut paramétrer la fréquence de sauvegarde dans les préférences de l’éditeur [edit=&gt;preference=&gt;onglet Advanced]. Par défaut la fréquence est de 4 secondes, ce qui semble suffisant.\nAprès un crash, ou autre mésaventure, il sera proposer d’ouvrir le fichier sauvegardé automatiquement.\nPenser également à enregistrer le programme de récupération avec le nom original.\n\nSolution pour les version antérieures: le log de session\nOn peut sauver les meubles en générant un log de session en tête de programme ou mieux en générant un log à chaque ouverture de session dans un fichier profile [[marche à suivre]https://mthevenin.github.io/stata_fr/articles/index/posts/profile/profile.html)].\n\nPour générer un log de session qui enregistrera en continu l’output de l’interface, et donc les lignes de commandes exécutée (sauf si exécution en mode run):\n\nfile =&gt; log =&gt; begin, puis choisir un emplacement pour l’enregistrement du fichier log.\nlog using \"path/nom_log.smcl\"\n\nCommande externe log2do2: à partir d’un fichier log, permet de conserver seulement les lignes de programmes en supprimant les éléments de l’output de types tableaux, warning et autre messages. Attention les lignes comportant des erreurs seront également conservée.\nssc install log2do2\n\n\n\n\n2.5.3.1 Interactions entre l’interface principale, les boîtes de dialogue et l’éditeur de programme\nDEMONSTRATION PENDANT LA FORMATION"
  },
  {
    "objectID": "chapitre3.html#la-syntaxe-générique",
    "href": "chapitre3.html#la-syntaxe-générique",
    "title": "3  Le langage Stata",
    "section": "3.1 La syntaxe générique",
    "text": "3.1 La syntaxe générique\nRemarque sur les crochets\n\n\n\n\n\n\n[…] expression entre crochets\n\n\n\nA ma connaissance, à l’exception des pondérations il n’y a pas d’utilisation de crochets dans la syntaxe des commandes usines. Dans les fichiers d’aide et pour cette formation, ils indiquent les expressions optionnelles d’une ligne d’instructions.\n\n\nForme concise de la syntaxe Stata pour une instruction portant sur des variables:\nExemple : tabulate var1 var2, nofreq row\nCe qui ce traduit par: produire un tableau croisé entre var1 (en ligne) et la var2 (en colonne) en affichant la répartition en % de var2 pour chaque valeur de var1 et pour l’ensemble des donnnées renseignées .\n\n\n\n\n\n(1978 automobile data)\n\n\n\ntabulate rep78 foreign, nofreq row\n\n\n    Repair |\n    record |      Car origin\n      1978 |  Domestic    Foreign |     Total\n-----------+----------------------+----------\n         1 |    100.00       0.00 |    100.00 \n         2 |    100.00       0.00 |    100.00 \n         3 |     90.00      10.00 |    100.00 \n         4 |     50.00      50.00 |    100.00 \n         5 |     18.18      81.82 |    100.00 \n-----------+----------------------+----------\n     Total |     69.57      30.43 |    100.00 \n\n\n\nForme générique de la syntaxe STATA\n\n\n[prefix:] command varlist [ [type_weight=var] if/in, options]\n\nExpression conditionnelle (sélection): if (sélection de valeurs) ou in (sélection d’observations)\nExemple : bysort var2: summarize var1 if var4!=1, detail\nCe qui ce traduit par: pour chaque valeur de var2, des statistiques descriptives détaillées pour la variable var1 si la valeur de var3 est différente de 1.\n\nbysort foreign: summarize price if rep78!=1, detail\n\n\n-------------------------------------------------------------------------------\n-&gt; foreign = Domestic\n\n                            Price\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%         3291           3291\n 5%         3667           3299\n10%         3892           3667       Obs                  50\n25%         4181           3799       Sum of wgt.          50\n\n50%       4782.5                      Mean            6132.74\n                        Largest       Std. dev.      3143.481\n75%         6303          13466\n90%        11441          13594       Variance        9881473\n95%        13594          14500       Skewness       1.717717\n99%        15906          15906       Kurtosis       4.857758\n\n-------------------------------------------------------------------------------\n-&gt; foreign = Foreign\n\n                            Price\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%         3748           3748\n 5%         3798           3798\n10%         3895           3895       Obs                  22\n25%         4499           3995       Sum of wgt.          22\n\n50%         5759                      Mean           6384.682\n                        Largest       Std. dev.      2621.915\n75%         7140           9690\n90%         9735           9735       Variance        6874439\n95%        11995          11995       Skewness       1.215236\n99%        12990          12990       Kurtosis       3.555178\n\n\n\nSi la commande implique une base de données, le nom de la base est généralement précédée de `using`` (sauf pour les instructions officielle d’ouverture/sauvegarde d’une base):\n\ncommand using nom_base [,options]"
  },
  {
    "objectID": "chapitre3.html#autres-langages-pris-en-charge",
    "href": "chapitre3.html#autres-langages-pris-en-charge",
    "title": "3  Le langage Stata",
    "section": "3.2 Autres langages pris en charge",
    "text": "3.2 Autres langages pris en charge\nInternes\n\nLangage matriciel (MATA)\nEditeur de texte (SMCL) pour rédiger les aides ou paramétrer la forme des outputs (c’est une une horreur)\nCréation de boites de dialogue (proche du Java)\nLa programmation de commande dispose d’un certain nombre d’éléments de langage dédié. Pour une réutilisation ultérieure automatisée, le programme est enregistré dans un fichier .ado\n\nExternes\nR\nVia une commande externe (rsource), on peut exécuter du R. R doit ête bien évidemment installé. Juste pour information:\n\nrsource, terminator(END_OF_R) \n\nlibrary(readr)\ntrans &lt;- read.csv(\"https://raw.githubusercontent.com/mthevenin/analyse_duree/master/bases/transplantation.csv\")\n\nhead(trans)\ntable(trans$died)\n\nEND_OF_R\n\n\n  id year age died stime surgery transplant wait mois compet\n1 15   68  53    1     1       0          0    0    1      1\n2 43   70  43    1     2       0          0    0    1      1\n3 61   71  52    1     2       0          0    0    1      1\n4 75   72  52    1     2       0          0    0    1      1\n5  6   68  54    1     3       0          0    0    1      2\n6 42   70  36    1     3       0          0    0    1      1\n\ntable(trans$died)\n\n 0  1 \n28 75 \n\nPython\nDepuis la version 16 on peut programmer intéractivement en Python. Cette intégration est suffisamment permet à Python de reconnaitre les macros Stata dans son code…c’est très utile. Python doit néanmoins être installé manuellement.\nVérification de l’installation\n\npython query\n\n-------------------------------------------------------------------------------\n    Python Settings\n      set python_exec      C:\\Users\\thevenin_m\\AppData\\Local\\Programs\\Python\\Py\n&gt; thon310\\python.exe\n      set python_userpath  \n\n    Python system information\n      initialized          yes\n      version              3.10.5\n      architecture         64-bit\n      library path         C:\\Users\\thevenin_m\\AppData\\Local\\Programs\\Python\\Py\n&gt; thon310\\python310.dll\n\n\nUtilisation de python\n\npython: \n\na = 4\nb = 2\na*b\n \nend\n\n\n\n\n\npython:\nimport pandas as pd\ntrans = pd.read_csv(\"https://raw.githubusercontent.com/mthevenin/analyse_duree/master/bases/transplantation.csv\")\n\ntrans.head(10)\ntrans.info()\nend\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 103 entries, 0 to 102\nData columns (total 10 columns):\n #   Column      Non-Null Count  Dtype\n---  ------      --------------  -----\n 0   id          103 non-null    int64\n 1   year        103 non-null    int64\n 2   age         103 non-null    int64\n 3   died        103 non-null    int64\n 4   stime       103 non-null    int64\n 5   surgery     103 non-null    int64\n 6   transplant  103 non-null    int64\n 7   wait        103 non-null    int64\n 8   mois        103 non-null    int64\n 9   compet      103 non-null    int64\n\n\n\ndtypes: int64(10)\nmemory usage: 8.2 KB\n\n\n\nAutres\n\nDepuis la version 17 de Stata, on peut également programmer intéractivement en Java… mais là je n’y connais absolument rien.\nIntégration de l’édition en markdown pour produire des rapports en html ou pdf. Egalement possibilité de générer des documents word ou excel avec des commandes dédiées. L’intégration de latex est également possible via une commande externe. Toutes ces possibilité me semble néanmoins nettement en très en deçà de ce qui est réalisable actuellement avec les outils proposés par Posit (ex Rstudio), en particulier avec le nouvel outil Quarto associé au notebook Jupyter (noyau nbstata). Ce sont ces qui sont utilisées pour faire ce support."
  },
  {
    "objectID": "chapitre3.html#les-opérateurs",
    "href": "chapitre3.html#les-opérateurs",
    "title": "3  Le langage Stata",
    "section": "3.3 Les opérateurs",
    "text": "3.3 Les opérateurs\n\n\n\nOpérateurs\n\n\n\n\n& Et\n\n\n| [Alt+Gr6] Ou\n\n\nOpérateurs d’affectation\n\n\n=\n\n\nOpérateurs pour expressions conditionnelles\n\n\n==\n\n\n!=\n\n\n&gt;\n\n\n&gt;=\n\n\n&lt;\n\n\n&lt;=\n\n\nOpérateurs arithmétique\n\n\n+ , - , / , ^ (puissance)\n\n\nOpérateur chaîne de caractères\n\n\n+\n\n\n\n[1] + concatène des variables caractères qui n’ont pas de valeur manquante. Sinon utiliser concat associée à la commande egen (voir chapitre sur la création de variables)."
  },
  {
    "objectID": "chapitre3.html#les-valeurs-manquantes",
    "href": "chapitre3.html#les-valeurs-manquantes",
    "title": "3  Le langage Stata",
    "section": "3.4 Les valeurs manquantes",
    "text": "3.4 Les valeurs manquantes\n\n\n\n\n\n\nStatut des valeurs manquantes\n\n\n\nLa valeur d’une observation manquante dépasse la plus grande valeur observée d’une variable. Ceci doit être pris en compte dans les expressions conditionnelles impliquant par exemple des regroupement de variables ordinales ou mésurées (âge, revenus…):\nSi une variable numérique \\(X\\) a des observations manquantes, la condition if X&gt;valeur conservera ces informations.\nSi \\(X=(1, 2, 3, 4, 5, 6, .)\\):\n\n...if x&gt;4 conserve \\(x=(5,6,.)\\)\n\n...if x&gt;4 & x&lt;. ou ...if x&gt;4 & x!=. regroupe seulement \\(x=(5,6)\\)\n\n\n\nLes valeurs manquantes utilisateurs\nOn peut rendre la valeur manquante informative en lui ajoutant une lettre: .a , .b, .c etc….\nExemple:\n\n.a = Ne sait pas.\n.b =Refus.\n.c =Pas de réponse.\n\nRepérage des valeurs manquantes\nDes commandes, comme tabulate avec l’option mis pour les variables catégorielles, permettent de repérer et d’afficher le nombre d’observations manquantes.\nIl y a aussi plusieurs commandes qui permettent d’analyser ce type d’observations observations globalement.\n\nCommande externe mdesc: affiche pour chaque variable de la base ou une sélection de celle, le nombre et le % d’observations manquantes.\n\ninstallation: ssc install mdesc\nsyntaxe: mdesc [varlist]\n\n\n\nsysuse auto.dta, clear\n\nmdesc\n\n(1978 automobile data)\n\n    Variable    |     Missing          Total     Percent Missing\n----------------+-----------------------------------------------\n           make |           0             74           0.00\n          price |           0             74           0.00\n            mpg |           0             74           0.00\n          rep78 |           5             74           6.76\n       headroom |           0             74           0.00\n          trunk |           0             74           0.00\n         weight |           0             74           0.00\n         length |           0             74           0.00\n           turn |           0             74           0.00\n   displacement |           0             74           0.00\n     gear_ratio |           0             74           0.00\n        foreign |           0             74           0.00\n----------------+-----------------------------------------------\n\n\n\ncommandes externes mvpatterns et misschk pour analyser les différents patterns de valeurs manquantes (une même observation peut avoir des valeurs manquantes sur plusieurs variables). misschk ne scanne que les variables de type numérique, et permet de générer deux variables pour indiquer le nombre et le pattern de valeurs manquantes pour chaque observation.\n\ninstallation: ssc install mvpatterns et ssc install misschk\nsyntaxe: mvpatterns [varlist] et misschk [varlist], gen(nom)\n\n\n\nmvpatterns\n\nvariables with no mv's: make price mpg headroom trunk weight length turn\n                    displacement gear_ratio foreign\n\nVariable     | type     obs   mv   variable label\n-------------+---------------------------------------\nrep78        | int       69    5   Repair record 1978\n-----------------------------------------------------\n\nPatterns of missing values\n\n  +------------------------+\n  | _pattern   _mv   _freq |\n  |------------------------|\n  |        +     0      69 |\n  |        .     1       5 |\n  +------------------------+\n\n\n\nmisschk\n\n\nVariables examined for missing values\n\n   #  Variable        # Missing   % Missing\n--------------------------------------------\n   1  price                 0         0.0\n   2  mpg                   0         0.0\n   3  rep78                 5         6.8\n   4  headroom              0         0.0\n   5  trunk                 0         0.0\n   6  weight                0         0.0\n   7  length                0         0.0\n   8  turn                  0         0.0\n   9  displacement          0         0.0\n   10 gear_ratio            0         0.0\n   11 foreign               0         0.0\n\nWarning: this output does not differentiate among extended missing.\nTo generate patterns for extended missing, use extmiss option.\n\n   Missing for |\n         which |\n    variables? |      Freq.     Percent        Cum.\n---------------+-----------------------------------\n __3__ _____ _ |          5        6.76        6.76\n _____ _____ _ |         69       93.24      100.00\n---------------+-----------------------------------\n         Total |         74      100.00\n\nMissing for |\n   how many |\n variables? |      Freq.     Percent        Cum.\n------------+-----------------------------------\n          0 |         69       93.24       93.24\n          1 |          5        6.76      100.00\n------------+-----------------------------------\n      Total |         74      100.00"
  },
  {
    "objectID": "chapitre3.html#casse-et-troncature",
    "href": "chapitre3.html#casse-et-troncature",
    "title": "3  Le langage Stata",
    "section": "3.5 Casse et troncature",
    "text": "3.5 Casse et troncature"
  },
  {
    "objectID": "chapitre3.html#sensibilité-à-la-casse",
    "href": "chapitre3.html#sensibilité-à-la-casse",
    "title": "3  Le langage Stata",
    "section": "3.6 Sensibilité à la casse",
    "text": "3.6 Sensibilité à la casse\nComme R ou Python, Stata est intégralement sensible à la casse pour les instructions, seulement en minuscules. Par exemple TABULATE X renverra un message d’erreur.\n\n3.6.1 Troncature des instructions et des options\nDans le fichier d’aire d’une commande usine ou externe, le niveau de troncature est indiqué par un soulignement dans l’instruction: par exemple tabulate est souligné au niveau de ta : tabulate = tabulat = tabula = tabul = tabu = tab = ta. On utilise généralement tabulate ou tab.\nA manier avec une certaine précaution car le programme peut devenir rapidement incompréhensible, surtout s’il est partagé entre personnes dont la pratique diffère à ce niveau:\n\ntabulate var1 var2, nofreq row miss  \n\n* est équivalent à: \n\nta var1 var2, nof r m"
  },
  {
    "objectID": "chapitre3.html#suppression-de-loutput-et-affichage-dune-expression",
    "href": "chapitre3.html#suppression-de-loutput-et-affichage-dune-expression",
    "title": "3  Le langage Stata",
    "section": "3.7 Suppression de l’output, et affichage d’une expression",
    "text": "3.7 Suppression de l’output, et affichage d’une expression\nOn peut rendre le résultat d’une commande invisible dans la fenêtre output avec quietly (qui).\n\n    tab rep78\nqui tab rep78\n\n\n     Repair |\nrecord 1978 |      Freq.     Percent        Cum.\n------------+-----------------------------------\n          1 |          2        2.90        2.90\n          2 |          8       11.59       14.49\n          3 |         30       43.48       57.97\n          4 |         18       26.09       84.06\n          5 |         11       15.94      100.00\n------------+-----------------------------------\n      Total |         69      100.00\n\n\nRemarque: ne fonctionne pas avec les graphiques où l’on doit utiliser l’option nodraw\ndisplay (di)\nCe n’est pas une commande à proprement parler, mais l’instruction display (di) permet d’afficher dans l’output, entres autres, des opérations arithmétiques (c’est donc une calculatrice).\n\ndi exp(1)/(1+exp(1))\ndi \"SALUT LES GENS!!!!\"\n\n.73105858\nSALUT LES GENS!!!!\n\n\nElle est également utilisé pour vérifier le contenu d’une macro variable, de préférence lorsque cette macro implique des valeurs."
  },
  {
    "objectID": "chapitre3.html#sélection-groupées-de-variables",
    "href": "chapitre3.html#sélection-groupées-de-variables",
    "title": "3  Le langage Stata",
    "section": "3.8 Sélection groupées de variables",
    "text": "3.8 Sélection groupées de variables\nCommandes associées pour filtrer: keep, drop [pour sélectionner des obseravations: keep if, drop if]\nOn peut sélectionner un ensemble de variables qui ont une racine commune, par exemple c, en écrivant : *c*.\nExemple:\ntelevision, telephone, table ont comme racine t. Pour supprimer ces variables, on peut exécuter drop t* au lieu de drop television telephone table.\nSi on souhaite supprimer television et telephone seulement : drop tele*.\nSi on veut sélectionner des variables occurencées ou comme dans la base auto les 5 variables qui se suivent [headroom, trunk, weight, length, turn]: keep headroom-turn . Pour des variables occurencées de x1 à x5: keep x1-x5.\n\nsum t*\n\n\n    Variable |        Obs        Mean    Std. dev.       Min        Max\n-------------+---------------------------------------------------------\n       trunk |         74    13.75676    4.277404          5         23\n        turn |         74    39.64865    4.399354         31         51"
  },
  {
    "objectID": "chapitre3.html#macros-et-répétition",
    "href": "chapitre3.html#macros-et-répétition",
    "title": "3  Le langage Stata",
    "section": "3.9 Macros et répétition",
    "text": "3.9 Macros et répétition\n\n3.9.1 Introduction au macros\nJuste une introduction…Vu la simplicité du langage Stata, il est conseiller de se mettre rapidement à la manipulation des expressions dites macro.\n\nUne macro, dans sa version la plus simple, est une expression qui est utilisée une ou plusieurs fois dans un programme. Elle sont de type temporaire (local) ou enregistré en dur (global).\nLes commandes, en particulier sur les opérations statistiques, enregistre un certains nombre d’objet de type macro qui peuvent être utilisés ultérieurement. On peut récupérer leur liste à la fin du fichier d’aide, et les visualiser les valeurs enregistrées après avoir exécuté une commande avec return list, ereturn list…\n\nUn autre type d’objet, appelé scalar ressemble à une macro mais n’en est pas. Il s’agit de pseudo variables. Ils ne seront pas traités.\nLe contenu d’une macro peut être affiché avec display ou macro list (mac list)\n\nprivilégier display pour afficher le contenu d’une macro de type valeur\nprivilégier mac list pour afficher le contenu d’une macro de type chaîne de caractère lorsque des doubles quotes (“) doivent rester apparentes. La gestion des” dans les macros peut s’avérer particulièrement retord.\n\nmacro local: mac list _macroname\n\nmacro global: mac list macroname\n\n\n\nMacro temporaire\nL’instruction local permet de définir des macros variables temporaire (disparaissent après l’exécution du programme):\n\nlocal nom_macro expression\n* ou\nlocal nom_macro = expression numérique\n\n* ou\n\nlocal nom_macro :  fonction macro // hors contenu de la formation\n\n\nlocal a = 2\n\ndi `a'\n\ndi 5^(`a')\n\n2\n25\n\n\n\nlocal var mpg foreign\n\ndi \"`var'\"\nmac list _var\n\nsum `var'\n\nregress price `var'\n\nmpg foreign\n_var:           mpg foreign\n\n    Variable |        Obs        Mean    Std. dev.       Min        Max\n-------------+---------------------------------------------------------\n         mpg |         74     21.2973    5.785503         12         41\n     foreign |         74    .2972973    .4601885          0          1\n\n      Source |       SS           df       MS      Number of obs   =        74\n-------------+----------------------------------   F(2, 71)        =     14.07\n       Model |   180261702         2  90130850.8   Prob &gt; F        =    0.0000\n    Residual |   454803695        71  6405685.84   R-squared       =    0.2838\n-------------+----------------------------------   Adj R-squared   =    0.2637\n       Total |   635065396        73  8699525.97   Root MSE        =    2530.9\n\n\n\n------------------------------------------------------------------------------\n\n\n       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]\n\n\n-------------+----------------------------------------------------------------\n\n\n         mpg |\n\n\n   -294.196     55.692    -5.28   0.000     -405.242    -183.149\n     foreign |   1767.292    700.158     2.52   0.014      371.217    3163.368\n       _cons |  11905.415   1158.634    10.28   0.000     9595.164   14215.667\n\n\n------------------------------------------------------------------------------\n\n\nOn remarque tout de suite l’utilité de ces expression: si on veut changer la liste de variables pour les instructions sum (troncature de summarize) et pour regress, on le fais une seule fois (dans la définition de la macro) au lieu de deux.\nAvec Stata peut définir également des macros dites global qui sont sauvegardées et s’appliqueront à tous les programmes (on peut les supprimer). Leur utilisation est moins courante: global nom_macro expression, le nom de la macro dans l’expression s’écrira $nom_macro.\nIl est conseillé de les supprimer en fin de programme avec macro drop + noms des macros.\n\nglobal var mpg weight length turn\n\ndi \"$var\"\nmac list var\n\nsum $var\nregress price $var, noheader\n\nmacro drop var\n\nmpg weight length turn\nvar:            mpg weight length turn\n\n    Variable |        Obs        Mean    Std. dev.       Min        Max\n-------------+---------------------------------------------------------\n         mpg |         74     21.2973    5.785503         12         41\n      weight |         74    3019.459    777.1936       1760       4840\n      length |         74    187.9324    22.26634        142        233\n        turn |         74    39.64865    4.399354         31         51\n------------------------------------------------------------------------------\n       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n         mpg |    -94.651     80.879    -1.17   0.246     -256.000      66.697\n      weight |      5.030      1.154     4.36   0.000        2.728       7.332\n      length |    -73.147     40.212    -1.82   0.073     -153.368       7.074\n        turn |   -323.861    126.882    -2.55   0.013     -576.983     -70.738\n       _cons |  19581.418   6005.223     3.26   0.002     7601.327   31561.509\n------------------------------------------------------------------------------\n\n\nLa liste des macro enregistrées en dur est donnée par l’instruction: macro dir\n\nmac dir\n\nS_E_depv:       price\nS_E_cmd:        regress\nS_2:            1\nS_1:            __000003\nRterm_options:  --vanilla\nRterm_path:     C:\\Program Files\\R\\R-4.1.2\\bin\\R.exe\ntmp:            D:\\D\\stata_temp\\\nuser:           C:\\Users\\thevenin_m\\\nS_level:        95\nF1:             help advice;\nF2:             describe;\nF7:             save\nF8:             use\nS_ADO:          BASE;SITE;.;PERSONAL;PLUS;OLDPLACE\nS_StataSE:      SE\nS_CONSOLE:      console\nS_OS:           Windows\nS_OSDTL:        64-bit\nS_MACH:         PC (64-bit x86-64)\n_width:         78\n_width_col1:    13\n_var:           mpg foreign\n_a:             2\nS_FN:           C:\\Program Files\\Stata18/ado\\base/a/auto.dta\nS_FNDATE:       13 Apr 2022 17:45\n\n\n\n\n3.9.2 Objets sauvegardés lors de l’exécution d’une commande\n\nCes objets de type macro ne sont conservés en mémoire qu’entre 2 commandes exécutés.\nOn peut donc les manipuler qu’à ce moment là, en particulier les enregistrer sous forme de macro standard pour les utiliser ultérieurement (exemple: normaliser automatiquement une pondération, reporter des moyennes dans un graphique etc….)\n\n\nqui sum price\n\nreturn list\n\nlocal mprice = r(mean)\n\ndi `mprice'\n\n\nscalars:\n                  r(N) =  74\n              r(sum_w) =  74\n               r(mean) =  6165.256756756757\n                r(Var) =  8699525.974268788\n                 r(sd) =  2949.495884768919\n                r(min) =  3291\n                r(max) =  15906\n                r(sum) =  456229\n6165.2568\n\n\n\n\n\n\n\n\nNote\n\n\n\nUne application typique est la normalisation d’une pondération brute (somme des poids = nombre d’observation dans l’échantillon).\nSi wb est la pondération brute (somme des poids = population cible), et wn les poids que l’on souhaite normaliser:\n\nqui sum wb\ngenerate wn = wb/`r(mean)'\n\nTout changement de la variable wb modifiera automatiquement cette normalisation.\nPour la commande **gen (ou generate) se reporter au chapitre 5."
  },
  {
    "objectID": "chapitre3.html#répétition-avec-des-boucles",
    "href": "chapitre3.html#répétition-avec-des-boucles",
    "title": "3  Le langage Stata",
    "section": "3.10 Répétition avec des boucles",
    "text": "3.10 Répétition avec des boucles\n\nforvalues: valeurs occurencées, compteur\n\nfor num 1/n: commande est de plus en plus abandonnée (aide Stata supprimée). On lui préfère maintenant l’instruction forvalues pour effectuer des boucles sur des occurences numériques.\nSi l’on souhaite par exemple changer le nom des variables x1 à x9 en var1, var2,…., var9:\n\nforvalues i=1/9 {\n  \nrename x`i' var`i' \n  \n}\n\n\nforeach: termes d’une expression enregistrée sous la forme d’une macro\n\nPar l’exemple, et juste une petite introduction. On veut faire une régression linéaire entre la variable price et la variable foreign en ajoutant une seule autre variable dans cette liste: mpg, headroom, trunk.\nAu lieu d’exécuter:\n\nregress price foreign mpg      \nregress price foreign headroom \nregress price foreign trunk    \n\nOn génère une macro variable temporaire qui liste ces 3 variables , et on exécute une boucle avec l’instruction foreach.\n\nlocal var mpg headroom trunk\n\nforeach x of local var {\n\nregress price foreign `x', noheader\n}\n\n------------------------------------------------------------------------------\n       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n     foreign |   1767.292    700.158     2.52   0.014      371.217    3163.368\n         mpg |   -294.196     55.692    -5.28   0.000     -405.242    -183.149\n       _cons |  11905.415   1158.634    10.28   0.000     9595.164   14215.667\n------------------------------------------------------------------------------\n------------------------------------------------------------------------------\n\n\n       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n     foreign |    577.812    787.566     0.73   0.466     -992.549    2148.174\n    headroom |    491.575    428.405     1.15   0.255     -362.641    1345.791\n       _cons |   4522.071   1412.097     3.20   0.002     1706.430    7337.711\n------------------------------------------------------------------------------\n------------------------------------------------------------------------------\n       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n     foreign |   1190.155    760.805     1.56   0.122     -326.847    2707.157\n       trunk |    262.772     81.852     3.21   0.002       99.564     425.980\n       _cons |   2196.541   1267.857     1.73   0.088     -331.494    4724.576\n------------------------------------------------------------------------------\n\n\n….et on peut aller plus loin… Juste pour information car cela se complique (et pas qu’un peu), avec une technique de macro empilée, on ajoute les les variables une à une au modèle.\n\nlocal j mpg weight length turn headroom trunk\n\nforeach j2 of local j {\nlocal x `x' `j2'\n  \ndi  \"covariables introduites = `x'\"  // pour afficher ce qui est lu dans la macro\n  \nregress price `x' , noheader\n}\n\ncovariables introduites = mpg\n------------------------------------------------------------------------------\n       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n         mpg |   -238.894     53.077    -4.50   0.000     -344.701    -133.088\n       _cons |  11253.061   1170.813     9.61   0.000     8919.088   13587.033\n------------------------------------------------------------------------------\ncovariables introduites = mpg weight\n\n\n------------------------------------------------------------------------------\n       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n         mpg |    -49.512     86.156    -0.57   0.567     -221.302     122.278\n      weight |      1.747      0.641     2.72   0.008        0.468       3.025\n       _cons |   1946.069   3597.050     0.54   0.590    -5226.245    9118.382\n------------------------------------------------------------------------------\ncovariables introduites = mpg weight length\n------------------------------------------------------------------------------\n       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n         mpg |    -86.789     83.943    -1.03   0.305     -254.209      80.630\n      weight |      4.365      1.167     3.74   0.000        2.036       6.693\n      length |   -104.868     39.722    -2.64   0.010     -184.090     -25.646\n       _cons |  14542.434   5890.632     2.47   0.016     2793.940   26290.929\n------------------------------------------------------------------------------\ncovariables introduites = mpg weight length turn\n\n\n------------------------------------------------------------------------------\n       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n         mpg |    -94.651     80.879    -1.17   0.246     -256.000      66.697\n      weight |      5.030      1.154     4.36   0.000        2.728       7.332\n      length |    -73.147     40.212    -1.82   0.073     -153.368       7.074\n        turn |   -323.861    126.882    -2.55   0.013     -576.983     -70.738\n       _cons |  19581.418   6005.223     3.26   0.002     7601.327   31561.509\n------------------------------------------------------------------------------\ncovariables introduites = mpg weight length turn headroom\n------------------------------------------------------------------------------\n       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n         mpg |    -96.145     80.259    -1.20   0.235     -256.300      64.010\n      weight |      5.015      1.145     4.38   0.000        2.730       7.300\n      length |    -60.922     40.791    -1.49   0.140     -142.319      20.476\n        turn |   -332.592    126.045    -2.64   0.010     -584.111     -81.073\n    headroom |   -538.252    373.149    -1.44   0.154    -1282.859     206.356\n       _cons |  19317.280   5961.554     3.24   0.002     7421.185   31213.375\n------------------------------------------------------------------------------\ncovariables introduites = mpg weight length turn headroom trunk\n\n\n------------------------------------------------------------------------------\n       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]\n-------------+----------------------------------------------------------------\n         mpg |    -94.063     80.371    -1.17   0.246     -254.484      66.357\n      weight |      5.079      1.148     4.42   0.000        2.788       7.371\n      length |    -73.487     43.011    -1.71   0.092     -159.338      12.364\n        turn |   -327.070    126.311    -2.59   0.012     -579.188     -74.952\n    headroom |   -731.292    427.369    -1.71   0.092    -1584.324     121.740\n       trunk |     98.275    105.721     0.93   0.356     -112.745     309.295\n       _cons |  20447.251   6090.068     3.36   0.001     8291.424   32603.078\n------------------------------------------------------------------------------"
  },
  {
    "objectID": "chapitre4.html",
    "href": "chapitre4.html",
    "title": "4  Les bases de données",
    "section": "",
    "text": "5 Décrire le contenu d’une base"
  },
  {
    "objectID": "chapitre4.html#affectation-du-répertoire-de-travail",
    "href": "chapitre4.html#affectation-du-répertoire-de-travail",
    "title": "4  Les bases de données",
    "section": "4.1 Affectation du répertoire de travail",
    "text": "4.1 Affectation du répertoire de travail\nLa commande cd (Current Directory), permet d’indiquer le chemin d’accès du répertoire où se trouve la base à ouvrir ou à enregistrer. Si aucun chemin d’accès n’est spécifié, Stata ira chercher la base dans le répertoire par défaut (normalement C: ou D:).\nSyntaxe:\ncd \"path\"\nRemarque\nAvec cette commande, un seul repertoire de travail est actif. On peut élargir les possibilités en affectant des répertoires avec des macros variables locales ou globales"
  },
  {
    "objectID": "chapitre4.html#ouverture-et-sauvegarde-dune-base",
    "href": "chapitre4.html#ouverture-et-sauvegarde-dune-base",
    "title": "4  Les bases de données",
    "section": "4.2 Ouverture et sauvegarde d’une base",
    "text": "4.2 Ouverture et sauvegarde d’une base\n\n4.2.1 Ouverture\nCommande use\nSyntaxe sans chargement d’un répertoire:\nuse \"path/nom_base.dta\" [,clear]\nL’option clear permet d’effacer une base en cours d’utilisation. Il est conseillé de mettre cette option systématiquement. On peut également utiliser clear comme instruction avant d’ouvrir une base. on ne supprime pas la base du répertoire (commande erase), elle est juste écrasée dans la session.\nSyntaxe avec affectation d’un répertoire:\ncd \"path\"\nuse \"nom_base.dta\", clear \nou\ncd \"path\"\nclear\nuse \"nom_base.dta\" \nRemarque: pour les bases d’exemples préinstallées, on utilise la commande sysuse. Dans les fichiers d’aide, des exemples font également appels a des bases localisées sur des serveurs qui s’ouvrent avec la commande webuse.\nsysuse auto, clear\n\n\n\n\n\n\nNote\n\n\n\nOuverture d’une base stockée sur un git [github, gitlab …]\nDans un premier temps, comme pour cd il faut charger le répertoire où se trouve localisé la base, avec la commande webuse set. Par exemple sur mon dépôt git, une base d’exemple (logement.dta) pour une commande se trouve à cette adresse: https://github.com/mthevenin/stata_graphiques/tree/main/programmation/gjoint\nPour charger ce répertoire à distance:\nwebuse set  \"https://raw.githubusercontent.com//mthevenin/stata_graphiques/master/ressources/gjoint\"\nOn remarque que le chemin n’est pas identique au simple lien (spécificité des dépôt de type git).\nIl suffit ensuite de charger la base avec webuse\nwebuse logement.dta, clear\nOn revient au dépôt officiel de stata avec webuse set\nEn résumé avec un seul bloc d’instructions:\n\nwebuse set  \"https://raw.githubusercontent.com//mthevenin/stata_graphiques/master/ressources/gjoint\"\n\nwebuse \"logement.dta\", clear\n\nwebuse set\n\n\n\n\n(prefix now \"https://raw.githubusercontent.com//mthevenin/stata_graphiques/mast\n&gt; er/ressources/gjoint\")\n\n\n(prefix now \"https://www.stata-press.com/data/r18\")\n\n\n\n\n\n\n4.2.2 Sauvegarde\nCommandes save ou saveold\nsave \"path/nom_base.dta\" [, replace]     \nL’option replace permet d’écraser une version antérieure de la base. Obligatoire à partir de la 2ème sauvegarde, mais on peut l’utiliser dès la première sauvegarde (un message d’avertissement s’affiche).\n\nsysuse auto, clear  \n\nsave auto, replace\n\n(1978 automobile data)\nfile auto.dta saved\n\n\nsaveold permettra d’ouvrir une bases avec une version ancienne de Stata non compatibles avec la version courante. Cela commence à devenir moins critique, mais avec save il ne sera plus possible d’ouvrir une base avec une version inférieure à la 13 ou inférieur à la 13 (passage à l’encodage Utf8 avec la version 14).\n saveold \"path/nom_base.dta\", [replace] [version(#)] // # = numéro de la version de Stata: \nRemarque:\n\nEcrire l’extension .dta n’est pas obligatoire\nLes doubles quotes ne sont obligatoires que s’il y a un espace dans le chemin d’accès et/ou dans le nom de la base\n\nuse \"ma base\", clear \nuse ma_base,   clear\n\n\n4.2.3 Autres formats\n\n4.2.3.1 Importation/Exportation\nExcel et fichiers textes (.txt, .csv)\n\n\nLe plus simple est passer par le menu: files + [Import ou Export] qui dispose d’une fenêtre de prévisualisation.\n\nPour excel les commandes sont import excel et export excel\nPour des fichiers textes type csv (R), les commandes sont import delimited et export delimited\n\n\n**Exemples\n* exportation csv\nexport delimited using \"D:\\D\\stata_temp\\export_csv.csv\", replace\n\n* exportation xls\nexport excel using \"D:\\D\\stata_temp\\export_excel.xls\", firstrow(variables) replace\n\n* importation cxv\nimport delimited \"D:\\D\\stata_temp\\export_csv.csv\",  clear\n\n\n* importation xls\nimport excel \"D:\\D\\stata_temp\\export_excel.xls\", sheet(\"Sheet1\") firstrow clear\nSAS\n\nDepuis la version 16 de Stata il est possible d’importer directement des formats sas7bdat. Pas d’exportation possible.\nPour les versions antérieure, la solution installée via sasxport n’est pas satisfaisante. Il est alors conseillé d’utiliser le package externe savasas\n\nSas =&gt; Stata [importation]: commande usesas\n\nStata =&gt; Sas [exportation] : commande savasas\nSi le chemin d’accès à l’exécutable de SAS Windows n’est pas reconnu, il faut récupérer et éditer le fichier sasexe.do (à partir de la ligne 169), dont l’accès est donné dans le fichier d’aide.\n\nPour l’exportation, on peut générer un catalogue de format,en dur, avec l’option format.\n\n\nSPSS\n\nDepuis la dernière version de Stata (16), il est possible d’importer directement des bases de ce format.\nPas de possibilité d’exportation directe."
  },
  {
    "objectID": "chapitre4.html#création-dune-base-de-donnée-ajout-dobservations",
    "href": "chapitre4.html#création-dune-base-de-donnée-ajout-dobservations",
    "title": "4  Les bases de données",
    "section": "4.3 Création d’une base de donnée, ajout d’observations",
    "text": "4.3 Création d’une base de donnée, ajout d’observations\nOn peut créer une base de donnée, “vide”, avec la commande set obs n_obs\nclear \nset obs 100\nA une base existante, on peut ajouter des observations (en valeurs manquante) avec la commande insobs nbre_observation. Par défaut ces observations s’ajouteront après la dernière ligne (option before/after(position) pour renseigner la position de la première observation ajoutée.\ninsobs 10  // ajout de 10 observations à la base"
  },
  {
    "objectID": "chapitre4.html#tri-doublon-position-des-variables",
    "href": "chapitre4.html#tri-doublon-position-des-variables",
    "title": "4  Les bases de données",
    "section": "5.1 Tri, doublon, position des variables",
    "text": "5.1 Tri, doublon, position des variables\n\n5.1.1 Tri d’une base\nCommande sort\nsort varlist\n\nLa commande sort n’effectue que des tris croissants. Pour faire un tri décroissant, on peut utiliser la commande gsort. Tris croissants et décroissant peuvent se succéder dans une logique de cluster.\n\nsort varlist =&gt; tri croissant\ngsort + var1 =&gt; croissant var1\ngsort - var1 =&gt; décroissant var1\ngsort + var1 - var2 =&gt; croissant var1 et décroissant var2 dans chaque strate de var1\n\nLe tri d’une peut/doit être réalisé lorsqu’on veut répéter une instruction avec le préfixe bysort: bysort varlist: instruction. Il est imposé lorsqu’on souhaite apparier des bases [voir chapitre 6]\n\n\n* tri croissant sur la variable price\nsort price\n\n* tri décroissant sur la variable prix pour chaque niveau de la variable foreign\ngsort + foreign - price  \n\n\n5.1.2 Repérage et suppression des doublons\nRepérage et suppression des doublons\nCommande duplicates list/tag/drop [varlist]\nPermet de lister, repérer (avec gen(varname) ) ou supprimer des observations répliquées. Si la liste de variables n’est pas renseignée, elles toutes sont utilisées.\nSyntaxe:\nduplicates list [varlist]\n\nduplicates tag [varlist], gen(var)\n\nduplicates drop [varlist]\n\n\n5.1.3 Modifier la place des variables dans la base\nCommande order\nSyntaxe:\norder varlist, [first/last] [after/before(varname)]\n\norder foreign, first\norder rep78, after(foreign)\n\ndes\n\n\nContains data from C:\\Program Files\\Stata18/ado\\base/a/auto.dta\n Observations:            74                  1978 automobile data\n    Variables:            12                  13 Apr 2022 17:45\n                                              (_dta has notes)\n-------------------------------------------------------------------------------\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\nforeign         byte    %8.0g      origin     Car origin\nrep78           int     %8.0g                 Repair record 1978\nmake            str18   %-18s                 Make and model\nprice           int     %8.0gc                Price\nmpg             int     %8.0g                 Mileage (mpg)\nheadroom        float   %6.1f                 Headroom (in.)\ntrunk           int     %8.0g                 Trunk space (cu. ft.)\nweight          int     %8.0gc                Weight (lbs.)\nlength          int     %8.0g                 Length (in.)\nturn            int     %8.0g                 Turn circle (ft.)\ndisplacement    int     %8.0g                 Displacement (cu. in.)\ngear_ratio      float   %6.2f                 Gear ratio\n-------------------------------------------------------------------------------\nSorted by: foreign\n\n\nCette opération est particulièrement pour organiser sa base de données après la création de nouvelles variables."
  },
  {
    "objectID": "chapitre4.html#description-statistique-des-variables",
    "href": "chapitre4.html#description-statistique-des-variables",
    "title": "4  Les bases de données",
    "section": "5.2 Description statistique des variables",
    "text": "5.2 Description statistique des variables\nDans les menus de l’interface principale: Statistics =&gt; Summaries, tables & tests\n\n5.2.1 Variables quantitatives\n\n5.2.1.1 Tableaux d’indicateurs\n\n\n\n\n\n\nNote\n\n\n\nLes commandes qui sont rapidement décrites afficheront des indicateurs communs, typiquement la moyenne. Elles se distinguent par la forme de leur output facilitant plus ou moins les comparaisons, les possibilités offertes en termes de pondération, et sur la récupération des résultats (macro).\n\n\nCommande summarize\nComme son l’indique, la commande summarize, avec l’option detail (d) donne un résumé complet de la distribution d’une variable quantitative: moyenne, variance, quantiles, symétrie, applatissement ..nom l’indique l.)\nSyntaxe:\nsummarize varlist [, detail]\nSi on indique pas le nom d’au moins une variable, toutes les variables de la base seront sélectionnées.\nLa commande peut-être tronquée jusqu’à sum [Warning: il existe également une fonction sum pour générer des cumuls lors d’une création de variable - voir chapitre 5].\n\nsum price\n\nsum \n\n\n    Variable |        Obs        Mean    Std. dev.       Min        Max\n-------------+---------------------------------------------------------\n       price |         74    6165.257    2949.496       3291      15906\n\n    Variable |        Obs        Mean    Std. dev.       Min        Max\n-------------+---------------------------------------------------------\n     foreign |         74    .2972973    .4601885          0          1\n       rep78 |         69    3.405797    .9899323          1          5\n        make |          0\n       price |         74    6165.257    2949.496       3291      15906\n         mpg |         74     21.2973    5.785503         12         41\n-------------+---------------------------------------------------------\n    headroom |         74    2.993243    .8459948        1.5          5\n       trunk |         74    13.75676    4.277404          5         23\n      weight |         74    3019.459    777.1936       1760       4840\n      length |         74    187.9324    22.26634        142        233\n        turn |         74    39.64865    4.399354         31         51\n-------------+---------------------------------------------------------\ndisplacement |         74    197.2973    91.83722         79        425\n  gear_ratio |         74    3.014865    .4562871       2.19       3.89\n\n\n\nsum price length, d\n\n\n                            Price\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%         3291           3291\n 5%         3748           3299\n10%         3895           3667       Obs                  74\n25%         4195           3748       Sum of wgt.          74\n\n50%       5006.5                      Mean           6165.257\n                        Largest       Std. dev.      2949.496\n75%         6342          13466\n90%        11385          13594       Variance        8699526\n95%        13466          14500       Skewness       1.653434\n99%        15906          15906       Kurtosis       4.819188\n\n                        Length (in.)\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%          142            142\n 5%          154            147\n10%          157            149       Obs                  74\n25%          170            154       Sum of wgt.          74\n\n50%        192.5                      Mean           187.9324\n                        Largest       Std. dev.      22.26634\n75%          204            221\n90%          218            222       Variance       495.7899\n95%          221            230       Skewness      -.0409746\n99%          233            233       Kurtosis        2.04156\n\n\n\nbysort foreign: sum price, d\n\n\n-------------------------------------------------------------------------------\n-&gt; foreign = Domestic\n\n                            Price\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%         3291           3291\n 5%         3667           3299\n10%         3955           3667       Obs                  52\n25%         4184           3799       Sum of wgt.          52\n\n50%       4782.5                      Mean           6072.423\n                        Largest       Std. dev.      3097.104\n75%         6234          13466\n90%        11385          13594       Variance        9592055\n95%        13594          14500       Skewness       1.777939\n99%        15906          15906       Kurtosis       5.090316\n\n-------------------------------------------------------------------------------\n-&gt; foreign = Foreign\n\n                            Price\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%         3748           3748\n 5%         3798           3798\n10%         3895           3895       Obs                  22\n25%         4499           3995       Sum of wgt.          22\n\n50%         5759                      Mean           6384.682\n                        Largest       Std. dev.      2621.915\n75%         7140           9690\n90%         9735           9735       Variance        6874439\n95%        11995          11995       Skewness       1.215236\n99%        12990          12990       Kurtosis       3.555178\n\n\n\n\nAvantage: récupération des résultats sous forme de macro rapide.\nInconvénients: pas de sélection des indicateurs avec l’option detail, output pas adapté aux comparaisons.\n\nExtrait de l’aide summarize (help summarize)\n    summarize stores the following in r():\n\n    Scalars   \n      r(N)           number of observations\n      r(mean)        mean\n      r(skewness)    skewness (detail only)\n      r(min)         minimum\n      r(max)         maximum\n      r(sum_w)       sum of the weights\n      r(p1)          1st percentile (detail only)\n      r(p5)          5th percentile (detail only)\n      r(p10)         10th percentile (detail only)\n      r(p25)         25th percentile (detail only)\n      r(p50)         50th percentile (detail only)\n      r(p75)         75th percentile (detail only)\n      r(p90)         90th percentile (detail only)\n      r(p95)         95th percentile (detail only)\n      r(p99)         99th percentile (detail only)\n      r(Var)         variance\n      r(kurtosis)    kurtosis (detail only)\n      r(sum)         sum of variable\n      r(sd)          standard deviation\nInformations enregistrées pour la variable price\n\nqui sum price, d\n\nreturn list\n\n\nscalars:\n                  r(N) =  74\n              r(sum_w) =  74\n               r(mean) =  6165.256756756757\n                r(Var) =  8699525.97426879\n                 r(sd) =  2949.495884768919\n           r(skewness) =  1.653433511704859\n           r(kurtosis) =  4.819187528464004\n                r(sum) =  456229\n                r(min) =  3291\n                r(max) =  15906\n                 r(p1) =  3291\n                 r(p5) =  3748\n                r(p10) =  3895\n                r(p25) =  4195\n                r(p50) =  5006.5\n                r(p75) =  6342\n                r(p90) =  11385\n                r(p95) =  13466\n                r(p99) =  15906\n\n\nmean\nN’affiche que la moyenne et ses statistiques associées. L’option over permet de comparer les valeurs moyennes des modalités d’une variable catégorielle (over(varname)) ou un croisement des modalités de plusieurs variables (over(varlist))\n\nmean price  \nmean price, over(foreign)\n\n\nMean estimation                             Number of obs = 74\n\n\n\n--------------------------------------------------------------\n\n\n             |       Mean   Std. err.     [95% conf. interval]\n\n\n-------------+------------------------------------------------\n\n\n       price |\n\n\n   6165.257    342.872      5481.914    6848.600\n\n\n--------------------------------------------------------------\n\n\n\nMean estimation                                Number of obs = 74\n\n-----------------------------------------------------------------\n                |       Mean   Std. err.     [95% conf. interval]\n----------------+------------------------------------------------\nc.price@foreign |\n      Domestic  |\n\n\n   6072.423    429.491      5216.449    6928.398\n       Foreign  |   6384.682    558.994      5270.608    7498.756\n-----------------------------------------------------------------\n\n\n\nAvantage: output synthétique si la moyenne de plusieurs groupes comparées\nInconvénients: récupération des résultats via une matrice (on oublie)\n\ntabstat\nPermet de sélectionner les indicateurs avec l’option stat() (par défaut la moyenne). L’option by() permet de comparer le ou les indicateurs pour chaque niveau d’une variable catégorielle. Dans ce cas tabstat affiche également les résultats sur l’ensemble des observations (sinon ajouter l’option nototal).\n\ntabstat price  \ntabstat price, by(foreign)\n\n\n    Variable |      Mean\n-------------+----------\n       price |  6165.257\n------------------------\n\nSummary for variables: price\nGroup variable: foreign (Car origin)\n\n foreign |      Mean\n---------+----------\nDomestic |  6072.423\n Foreign |  6384.682\n---------+----------\n   Total |  6165.257\n--------------------\n\n\nExtrait de l’aide tabstat (help tabstat)\n\n        mean            mean\n        count           count of nonmissing observations\n        n               same as count\n        sum             sum\n        max             maximum\n        min             minimum\n        range           range = max - min\n        sd              standard deviation\n        variance        variance\n        cv              coefficient of variation (sd/mean)\n        semean          standard error of mean (sd/sqrt(n))\n        skewness        skewness\n        kurtosis        kurtosis\n        p1              1st percentile\n        p5              5th percentile\n        p10             10th percentile\n        p25             25th percentile\n        median          median (same as p50)\n        p50             50th percentile (same as median)\n        p75             75th percentile\n        p90             90th percentile\n        p95             95th percentile\n        p99             99th percentile\n        iqr             interquartile range = p75 - p25\n        q               equivalent to specifying p25 p50 p75\nSi on souhaite ajouter la médiane\n\ntabstat mpg, by(foreign) stat(mean median)\n\n\nSummary for variables: mpg\nGroup variable: foreign (Car origin)\n\n foreign |      Mean       p50\n---------+--------------------\nDomestic |  19.82692        19\n Foreign |  24.77273      24.5\n---------+--------------------\n   Total |   21.2973        20\n------------------------------\n\n\n\n\n5.2.1.2 Graphiques\n[MAJ EN COURS: bcp de nouveautés]\nJuste une rapide présentation de quelques visualisations permettant d’explorer des distributions.\nUne seule distribution: graph box/hbox , histogram, violinplot (externe)\nPlusieurs distributions: violinplot (externe) Deux distribution croisée: hexplot (externe), gjoint (externe)\nBoxplot\ngraph hbox mpg, \ngraph hbox mpg, over(foreign)   \n\n\n\n\n\nSans comparaison\n\n\n\n\n\nAvec comparaison\n\n\n\n\nHistogramme\nhistogram mpg, percent \nhistogram mpg, percent by(foreign)\n\n\n\n\n\nSans comparaison\n\n\n\n\n\nAvec comparaison\n\n\n\n\n\nDans le langage de Stata, ce type de graphique est appelé oneway.\nL’altération de son aspect avec les options n’est pas très flexible, surtout au niveau des couleurs.\nPour les histogrammes, il y a une version twoway qui permet d’empilé plusieurs histogrammes dans un même graphique, mais généralement la visualisation n’est pas optimale. Préférer en ce cas là une approche par les densités (voir violinplot - comparaison III).\nConseil de sémiologie graphique: garder l’axe quantitatif/continu sur les abcisses .\n\nViolinplot (Ben Jann)\nToujours beaucoup d’options dans les commandes de magik B.Jann. Se reporter à son tutoriel sur github pour l’installation (nécessite l’installation de dépendances) Lien\nviolinplot mpg, fill\n\nviolinplot mpg, nobox over(foreign) left overlay nomedian  dscale(.) \n\nviolinplot mpg, fill over(foreign)\n\nviolinplot mpg, fill split(foreign) horizontal\n\n\n\n\n\nSans comparaison\n\n\n\n\n\nComparaison I\n\n\n\n\n\n\n\nComparaison II\n\n\n\n\n\nComparaison III\n\n\n\n\nDeux variables quantitatives\n\nUne nuage de point pêche rapidement lorsque le nombre d’observations augmente, par exemple audelà de 200.\nSolutions:\n\nCourbes de niveaux\nHeatplot/hexplot: l’idée est de visualiser un histogramme “vu du dessuss”, la hauteurs des barres étant données par un différentiel de couleur issues d’une palette séquentielle (du clair au foncé par exemple).\n\n\nssc install heatplot, replace  \n\nIl peut-être intéressant d’ajouté les distributions marginales des deux variables. J’ai programmé une petite commande (encore en version très alpha): gjoint. Tout le mérite revient à B.Jann pour la commande hexplot (j’ai juste combiné hexplot avec des histogrammes).\n\nnet install gjoint, from(\"https://raw.githubusercontent.com/mthevenin/stata_graphiques/master/ressources/gjoint/\") replace\nhexplot price mpg, colors(flare)\ngjoint price mpg, palette(flare)\n\n\n\n\n\nhexplot\n\n\n\n\n\nhexplot\n\n\n\n\n\n\n\n5.2.2 Variables catégorielles\nLa principale commande est tabulate (tab). On peut l’utiliser avec des variables de type string.\nSyntaxe (tableau croisé):\ntab var1 var2 [, mis nofreq row col sort ......]\n\nPar défaut, l’ordre d’affichage suis la valeur de la modalité si la variable est de type numérique et l’ordre alphabétique pour une variable de type caractère. On peut utiliser l’option sort pour afficher par ordre croissant des effectifs observés [ou utiliser la commande externe tabsort qui offre plus de possibilités]\nAutres commandes (externe): fre [B.Jann], tabm [NJ.Cox], tabsort [NJ.Cox]\n\nssc install fre\nssc install tabsort\nssc install tabm\n\ntab rep78, mis\ntab rep78, mis sort \ntab rep78 foreign, nolab mis\n\nfre rep78 \n\ntabsort rep78\n\n\n     Repair |\nrecord 1978 |      Freq.     Percent        Cum.\n------------+-----------------------------------\n          1 |          2        2.70        2.70\n          2 |          8       10.81       13.51\n          3 |         30       40.54       54.05\n          4 |         18       24.32       78.38\n          5 |         11       14.86       93.24\n          . |          5        6.76      100.00\n------------+-----------------------------------\n      Total |         74      100.00\n\n     Repair |\nrecord 1978 |      Freq.     Percent        Cum.\n------------+-----------------------------------\n          3 |         30       40.54       40.54\n          4 |         18       24.32       64.86\n          5 |         11       14.86       79.73\n          2 |          8       10.81       90.54\n          . |          5        6.76       97.30\n          1 |          2        2.70      100.00\n------------+-----------------------------------\n      Total |         74      100.00\n\n    Repair |\n    record |      Car origin\n      1978 |         0          1 |     Total\n-----------+----------------------+----------\n         1 |         2          0 |         2 \n         2 |         8          0 |         8 \n         3 |        27          3 |        30 \n         4 |         9          9 |        18 \n         5 |         2          9 |        11 \n         . |         4          1 |         5 \n-----------+----------------------+----------\n     Total |        52         22 |        74 \n\n\n\nrep78 -- Repair record 1978\n-----------------------------------------------------------\n              |      Freq.    Percent      Valid       Cum.\n--------------+--------------------------------------------\nValid   1     |          2       2.70       2.90       2.90\n        2     |          8      10.81      11.59      14.49\n        3     |         30      40.54      43.48      57.97\n        4     |         18      24.32      26.09      84.06\n        5     |         11      14.86      15.94     100.00\n        Total |         69      93.24     100.00           \nMissing .     |          5       6.76                      \nTotal         |         74     100.00                      \n-----------------------------------------------------------\n\n     Repair |\nrecord 1978 |      Freq.     Percent        Cum.\n------------+-----------------------------------\n          3 |         30       43.48       43.48\n          4 |         18       26.09       69.57\n          5 |         11       15.94       85.51\n          2 |          8       11.59       97.10\n          1 |          2        2.90      100.00\n------------+-----------------------------------\n      Total |         69      100.00\n\n\nGraphiques\nNiveau graphique, les possibilités restent toujours assez limitées pour les variables discrètes (et on abandonne l’idée des horribles camemberts).\nOn privilégiera ici la commande de NJ.Cox, catplot\nssc install catplot\n\ncatplot rep78, percent \ncatplot rep78, percent over(foreign)\n\n\n\n\n\n\n\n\n\n\n\n\n\nSans comparaison\n\n\n\n\n\nAvec comparaison"
  },
  {
    "objectID": "chapitre4.html#introduction-aux-frames",
    "href": "chapitre4.html#introduction-aux-frames",
    "title": "4  Les bases de données",
    "section": "5.3 Introduction aux frames",
    "text": "5.3 Introduction aux frames\n\nDepuis la version 16 (2019)\nLes frames permettent de travailler en parallèle sur plusieurs bases, sans switcher avec des opérations successives d’enregistrement/ouverture (save/use).\n\nSur l’interface principale, le contenu d’une frame (base de données) est affiché de manière traditionnelle. On peut faire des opérations sur les autres frames déclarées simultanément.\nLa première base ouverte lors de l’ouverture d’une session est déclarée comme frame par défaut.\n\nLes frames peuvent être liées entre elles avec une clé d’identification commune.\n\nImportations partielles de variables ou d’observations d’une frame à l’autre.\nPermet de générer une variable dans une frame en utilisant des variables d’une ou plusieurs autres frames. Il n’est donc pas nécessaire d’apparier les bases entre elles en amont.\n\n\nOn ne verra ici que quelques manipulations de bases, la liaison de frames sera traitée dans le chapitre 6.\nframe dir ou frame mist\n\nframe dir\nframe list\n\n  default  74 x 12; 1978 automobile data\n  default  74 x 12; 1978 automobile data\n\n\n\nsysuse auto, clear\nframe dir\n\n(1978 automobile data)\n  default  74 x 12; 1978 automobile data\n\n\nframe rename\nOn renomme une frame avec ancien nom nouveau nom\n\nframe reset   // voir plus loin - commande ici seulement nécessaire pour compatibilité avec Quarto\nsysuse auto, clear\nframe rename default auto\n\nframe dir\n\n(1978 automobile data)\n  auto  74 x 12; 1978 automobile data\n\n\n\n\n\n\n\n\nNote\n\n\n\nAutre façon de procéder (et surement meilleure):\nframe create auto\nframe auto: sysuse auto, clear\n\n\nframe nom_frame: ou frame nom_frame {}\n\nOn peut exécuter une commande en la préfixant par frame nom_frame:\nPour une série de commandes, il suffit d’enchasser cette série dans des crochets\n\n\nframe auto: mean price\n\n\nMean estimation                             Number of obs = 74\n\n\n\n--------------------------------------------------------------\n             |       Mean   Std. err.     [95% conf. interval]\n-------------+------------------------------------------------\n       price |   6165.257    342.872      5481.914    6848.600\n--------------------------------------------------------------\n\n\n\nframe auto {\nmean mpg\ntable rep78 foreign  \n}\n\n\nMean estimation                             Number of obs = 74\n\n\n\n--------------------------------------------------------------\n             |       Mean   Std. err.     [95% conf. interval]\n-------------+------------------------------------------------\n         mpg |     21.297      0.673        19.957      22.638\n--------------------------------------------------------------\n\n\n\n\n\n------------------------------------------------\n                   |          Car origin        \n                   |  Domestic   Foreign   Total\n-------------------+----------------------------\nRepair record 1978 |                            \n  1                |         2                 2\n  2                |         8                 8\n  3                |        27         3      30\n  4                |         9         9      18\n  5                |         2         9      11\n  Total            |        48        21      69\n------------------------------------------------\n\n\nframe copy\nPermet de copier à l’idendique une frame frame copy nom_frame nouveau_nom.\nDans l’exemple qui suit on va une frame à partir de la base auto, frame prix, en conservant avec seulement les variables foreign et price.\n\nframe copy auto prix\n\nframe dir\n\n  auto  74 x 12; 1978 automobile data\n  prix  74 x 12; 1978 automobile data\n\n\nComme indiqué précédemment, on est pas obligé de charger une base déclarée en frame pour effectuer des opérations dessus. On peut donc conserver les deux seules variables foreign et price tout en gardant la base auto chargée.\n\nframe prix: keep foreign price\nframe dir\n\n  auto  74 x 12; 1978 automobile data\n* prix  74 x 2; 1978 automobile data\n\nNote: Frames marked with * contain unsaved data.\n\n\nLa frame prix ne comporte donc plus que deux variables.\nOn va supprimer la variable make de la base/frame auto\n\ndrop make\n\nframe change\nPermet de switcher d’une frame à une autre. Ici ce sont les informations de la frame prix qui seront chargée dans l’interface de Stata\n\nframe change prix \n\nmean price, over(foreign)\n\n\nMean estimation                                Number of obs = 74\n\n\n\n-----------------------------------------------------------------\n                |       Mean   Std. err.     [95% conf. interval]\n----------------+------------------------------------------------\nc.price@foreign |\n      Domestic  |   6072.423    429.491      5216.449    6928.398\n       Foreign  |   6384.682    558.994      5270.608    7498.756\n-----------------------------------------------------------------\n\n\nDu côté de la frame auto, base chargée initialement, on note que la suppression de la variable make a bien été enregistrée malgré le change de frame.\n\nframe auto: des\n\n\nContains data from C:\\Program Files\\Stata18/ado\\base/a/auto.dta\n Observations:            74                  1978 automobile data\n    Variables:            11                  13 Apr 2022 17:45\n                                              (_dta has notes)\n-------------------------------------------------------------------------------\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\nprice           int     %8.0gc                Price\nmpg             int     %8.0g                 Mileage (mpg)\nrep78           int     %8.0g                 Repair record 1978\nheadroom        float   %6.1f                 Headroom (in.)\ntrunk           int     %8.0g                 Trunk space (cu. ft.)\nweight          int     %8.0gc                Weight (lbs.)\nlength          int     %8.0g                 Length (in.)\nturn            int     %8.0g                 Turn circle (ft.)\ndisplacement    int     %8.0g                 Displacement (cu. in.)\ngear_ratio      float   %6.2f                 Gear ratio\nforeign         byte    %8.0g      origin     Car origin\n-------------------------------------------------------------------------------\nSorted by: foreign\n     Note: Dataset has changed since last saved.\n\n\nframe drop et frame reset\nPermettent de supprimer une ou la totalité des frames\nframe drop nom_frame, permet de supprimer une frame, à l’exception de celle chargée dans l’interface.\n\nframe change auto\n\nframe drop prix\n\nframe dir\n\n* auto  74 x 11; 1978 automobile data\n\nNote: Frames marked with * contain unsaved data.\n\n\nOn a chargé dans l’interface la frame auto, puis on a supprimé la frame prix. Par contre il n’est pas possible de supprimer la frame active dans l’interface.\n\n\n\n\n\n\nStata 18\n\n\n\nAvec la nouvelle version, il est possible de supprimer plusieurs frames avec frame drop, mais toujours à l’exception de celle qui est active.\n\n\nframe reset\nOn peut supprimer toutes les frames, dont celle chargée dans l’interface avec frame reset. Dans ce cas il n’y a plus de base chargée dans la session.\n\nframe reset\nsysuse auto, clear\nframe rename default auto\n\n(1978 automobile data)\n\n\n\nframe reset \n\ndes\n\n\nContains data\n Observations:             0                  \n    Variables:             0                  \nSorted by:"
  },
  {
    "objectID": "chapitre5.html",
    "href": "chapitre5.html",
    "title": "5  Les variables",
    "section": "",
    "text": "6 Les variables internes de comptage\nTrès utile avec des données longitudinales, de durées ou toute base avec des données avec clusters.\nDeux variables de comptage: _n et _N\nApplication: On veut créer un identifiant sur l’ensemble des observations de la base auto.\ncapture drop id\n\ngen id = _n\nlist make foreign id in 1/10\n\n\n     +----------------------+\n     | make    foreign   id |\n     |----------------------|\n  1. | AMC    Domestic    1 |\n  2. | AMC    Domestic    2 |\n  3. | AMC    Domestic    3 |\n  4. | Bui    Domestic    4 |\n  5. | Bui    Domestic    5 |\n     |----------------------|\n  6. | Bui    Domestic    6 |\n  7. | Bui    Domestic    7 |\n  8. | Bui    Domestic    8 |\n  9. | Bui    Domestic    9 |\n 10. | Bui    Domestic   10 |\n     +----------------------+\nOn peut associer bysort à la création de ce type de variables, par exemple pour générer un id unique aux personnes composant un ménage.\nlead & lag\nPar défaut, pour toutes les instructions le rang sélectionné est celui de la ligne de l’observation x=x[_n]\ngen lag_make  = make[_n-1]\ngen lead_make = make[_n+1]\n\nlist make lag_make lead_make in 1/10\n\n(1 missing value generated)\n(1 missing value generated)\n\n     +----------------------------+\n     | make   lag_make   lead_m~e |\n     |----------------------------|\n  1. | AMC                    AMC |\n  2. | AMC         AMC        AMC |\n  3. | AMC         AMC        Bui |\n  4. | Bui         AMC        Bui |\n  5. | Bui         Bui        Bui |\n     |----------------------------|\n  6. | Bui         Bui        Bui |\n  7. | Bui         Bui        Bui |\n  8. | Bui         Bui        Bui |\n  9. | Bui         Bui        Bui |\n 10. | Bui         Bui        Cad |\n     +----------------------------+"
  },
  {
    "objectID": "chapitre5.html#types-et-format",
    "href": "chapitre5.html#types-et-format",
    "title": "5  Les variables",
    "section": "5.1 Types et format",
    "text": "5.1 Types et format\n\n5.1.1 Types\nStata gère tous les types de variables: numérique, caractère, date. Un type de variable est un type de stockage.\n\nTypes numériques: float, long, double, int et byte.\nTypes caractère: str# et strL (très grandes chaînes de caractères). # est la longueur de la chaîne de caractère, elle ne peut pas excéder 2046 pour le type str.\n\nPlus d’informations: help data types\nModification du type de variable\n\nOptimisation du poids en mémoire avec compress\nCommande recast\n\nOptimisation du poids de la base\n\ncompress \n\n  variable mpg was int now byte\n  variable rep78 was int now byte\n  variable trunk was int now byte\n  variable turn was int now byte\n  variable make was str18 now str17\n  (370 bytes saved)\n\n\nPassage de la variable make en str3 avec recast\nEn réduisant le type, on va tronquer les chaînes de caractères qui ne garderont que les 3 premières lettres, à manipuler avec prudence donc. Pour cette opération, Stata impose une confirmation avec l’option force.\nVariable d’origine\n\ndes make \nlist make in 1/10\n\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\nmake            str17   %-17s                 Make and model\n\n     +---------------+\n     | make          |\n     |---------------|\n  1. | AMC Concord   |\n  2. | AMC Pacer     |\n  3. | AMC Spirit    |\n  4. | Buick Century |\n  5. | Buick Electra |\n     |---------------|\n  6. | Buick LeSabre |\n  7. | Buick Opel    |\n  8. | Buick Regal   |\n  9. | Buick Riviera |\n 10. | Buick Skylark |\n     +---------------+\n\n\nModification du type\n\nrecast str3 make, force\ndes make\nlist make in 1/10\n\nmake:  74 values changed\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\nmake            str3    %-9s                  Make and model\n\n     +------+\n     | make |\n     |------|\n  1. | AMC  |\n  2. | AMC  |\n  3. | AMC  |\n  4. | Bui  |\n  5. | Bui  |\n     |------|\n  6. | Bui  |\n  7. | Bui  |\n  8. | Bui  |\n  9. | Bui  |\n 10. | Bui  |\n     +------+\n\n\n\n\n5.1.2 Format\nIl s’agit du format d’affichage des valeurs des variables. Ils peuvent être modifiés sans que le type soit changé (décimales, alignement….).\nVariables numérique:\n- Format g: général (définition un peu obsure selon moi). - Format f: fixe. - Plusieurs format d’affichage pour les variables de type dates: %td (date avec jour-mois-année), %tm (mois), %tq (trimestre), %tw (semaine). Les dates et leur manipulation sont un domaines très riche, et feront l’objet d’une courte présentation en fin de chapite.\nOn peut changer le format d’affichage avec la commande format. Si le format est de type général (g), il est préférable de passer à un format de type fixe (f). On peut affecter un même format à une liste de variables.\nSyntaxe:\nformat %format varlist\nExemple: changement du nombre de décimales\nDans la base auto, la variable gear_ratio est de format fixe à 2 décimales (%6.2f). Pour supprimer, à l’affichage, les deux décimales:\n\nlist gear_ratio in 1/10\n\n\n     +----------+\n     | gear_r~o |\n     |----------|\n  1. |     3.58 |\n  2. |     2.53 |\n  3. |     3.08 |\n  4. |     2.93 |\n  5. |     2.41 |\n     |----------|\n  6. |     2.73 |\n  7. |     2.87 |\n  8. |     2.93 |\n  9. |     2.93 |\n 10. |     3.08 |\n     +----------+\n\n\n\nformat %6.0f gear_ratio\nlist gear_ratio in 1/10\n\n\n     +----------+\n     | gear_r~o |\n     |----------|\n  1. |        4 |\n  2. |        3 |\n  3. |        3 |\n  4. |        3 |\n  5. |        2 |\n     |----------|\n  6. |        3 |\n  7. |        3 |\n  8. |        3 |\n  9. |        3 |\n 10. |        3 |\n     +----------+\n\n\nExemple: aligner le nombre décimal reporté avec summarize sur le format de la variable\nAvec l’option format appliquée à la commande summarize on peut automatiquement réduire le nombre de décimales reportées dans l’output\n\nsum gear_ratio\nsum gear_ratio, d\n\n\n    Variable |        Obs        Mean    Std. dev.       Min        Max\n-------------+---------------------------------------------------------\n  gear_ratio |         74    3.014865    .4562871       2.19       3.89\n\n                         Gear ratio\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%         2.19           2.19\n 5%         2.28           2.24\n10%         2.43           2.26       Obs                  74\n25%         2.73           2.28       Sum of wgt.          74\n\n50%        2.955                      Mean           3.014865\n                        Largest       Std. dev.      .4562871\n75%         3.37           3.78\n90%         3.72           3.78       Variance       .2081979\n95%         3.78           3.81       Skewness       .2191658\n99%         3.89           3.89       Kurtosis       2.101812\n\n\nAvec l’option format\n\nsum gear_ratio, format\nsum gear_ratio, d format\n\n\n    Variable |        Obs        Mean    Std. dev.       Min        Max\n-------------+---------------------------------------------------------\n  gear_ratio |         74           3           0          2          4\n\n                         Gear ratio\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%            2              2\n 5%            2              2\n10%            2              2       Obs                  74\n25%            3              2       Sum of wgt.          74\n\n50%            3                      Mean                  3\n                        Largest       Std. dev.             0\n75%            3              4\n90%            4              4       Variance              0\n95%            4              4       Skewness              0\n99%            4              4       Kurtosis              2"
  },
  {
    "objectID": "chapitre5.html#modification-du-type",
    "href": "chapitre5.html#modification-du-type",
    "title": "5  Les variables",
    "section": "5.2 Modification du type",
    "text": "5.2 Modification du type\nIl est possible de basculer d’un type caractère à un type numérique et inversement\nDe numérique à caractère\nSi la variable numérique n’a pas de label affecté sur les modalités, ou qu’on ne veut pas conserver l’information données par les labels, on peut utiliser la commande tostring. On peut créer une nouvelle variable avec l’option gen() ou remplacer la variable numérique d’origine avec l’option replace. Une des deux options doit être nécessairement renseignée.\nSyntaxe:\n  tostring [varlist], gen(nom_varlist)\n  tostring [varlist], replace\nExemple avec la variable foreign qui prend les valeurs 0 ou 1 avec les labels “domestic” (0) et “foreign” (1)\n\ntostring foreign, gen(foreign_str)\ndes foreign foreign_str\n\ntab foreign foreign_str\n\nforeign_str generated as str1\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\nforeign         byte    %8.0g      origin     Car origin\nforeign_str     str1    %9s                   Car origin\n\n           |      Car origin\nCar origin |         0          1 |     Total\n-----------+----------------------+----------\n  Domestic |        52          0 |        52 \n   Foreign |         0         22 |        22 \n-----------+----------------------+----------\n     Total |        52         22 |        74 \n\n\nSi la variable numérique a des labels affectés aux modalités modalités et qu’on souhaite conserver cet information, on utilise la commande decode\nSyntaxe:\n  decode variable, gen(nom_var)\nExemple avec la variable foreign\n\ncapt drop foreign_str\n\ndecode foreign, gen(foreign_str)\n\ndes foreign foreign_str\n\ntab foreign_str\n\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\nforeign         byte    %8.0g      origin     Car origin\nforeign_str     str8    %9s                   Car origin\n\n Car origin |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   Domestic |         52       70.27       70.27\n    Foreign |         22       29.73      100.00\n------------+-----------------------------------\n      Total |         74      100.00\n\n\nDe caractère à numérique\nSi la variable caractère est a une forme numerique (une suite de nombre comme des années, des âges…), on utilise la commande destring. Lorsqu’il y a des des valeurs manquantes à la variable, on doit uiliser l’option force.\nSyntaxe:\n destring [varlist] , gen(nom_varlist) \n destring [varlist] , replace [force]\nExemple avec la variable rep78 qui est transformé dans un premier temps en variables caractère avec tostring puis de nouveau transformé en format numérique avec destring\n\ntostring rep78, replace\ndes rep78\n\ndestring rep78, replace\ndes rep78\n\nrep78 was byte now str1\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\nrep78           str1    %9s                   Repair record 1978\nrep78: all characters numeric; replaced as byte\n(5 missing values generated)\n\n\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\nrep78           byte    %10.0g                Repair record 1978\n\n\nSi la variable caractère n’est pas de forme numérique et que l’on souhaite récupérer les labels sur les modalités, on peut utiliser la commande encode ou la commande externe sencode (net install st0043_2, force). La seconde permet de remplacer directement la variable d’origine, option particulièrement pratique. Egalement, cette commande permet plus de souplesse sur le codage de la variable (help sencode pour plus de détail).\nAvec encode ou sencode sans l’option gsort, le numéro de la modalité suivra l’ordre alphabétique des chaînes de caractère de la variable: si la variable caractère à pour valeur (“Homme”, “Femme”), “femme” sera automatiquement codée 1 et “homme” 2.\nSyntaxe:\nencode variable, gen(nom_variable)\nSyntaxe:\nsencode variable, gen(nom_variable) replace gsort()\nExemple avec la variable foreign_str (variable caractère créée précédemment à partir de la variable foreign)\n\nencode foreign_str, gen(foreign2)\n\ntab foreign2\ntab foreign2, nolab\n\n\n Car origin |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   Domestic |         52       70.27       70.27\n    Foreign |         22       29.73      100.00\n------------+-----------------------------------\n      Total |         74      100.00\n\n Car origin |      Freq.     Percent        Cum.\n------------+-----------------------------------\n          1 |         52       70.27       70.27\n          2 |         22       29.73      100.00\n------------+-----------------------------------\n      Total |         74      100.00\n\n\n\n\n\n\n\n\nType de variable pour les modèles\n\n\n\nLes variables de type caractères ne sont pas acceptées, Stata renvoie alors un message d’erreur avec no observation. Si c’est le cas, les commandes destring et encode vont s’avérer particulièrement utiles."
  },
  {
    "objectID": "chapitre5.html#création-dune-variable",
    "href": "chapitre5.html#création-dune-variable",
    "title": "5  Les variables",
    "section": "5.3 Création d’une variable",
    "text": "5.3 Création d’une variable\n\n5.3.1 generate - replace\nLa création d’une nouvelle variable se fait avec la commande generate généralement tronquée jusqu’à gen (voire ge pour les plus radicaux de la troncature de syntaxe).\nSyntaxe:\ngen nom_variable=valeur/fonction [expression: if in inlist inrange...]\nPour remplacer la valeur variable existante on utilise la commande replace. Le nom n’est malheureusement pas tronquable.\nSyntaxe:\nreplace nom_variable=valeur/fonction [expression: if in inlist inrange...]\n\nOn peut utiliser le préfixe bysort\nPour utiliser une fonction mathématique (log, exp,….) =&gt; help math_functions\nPour afficher la liste complète des fonctions (variables caractères, statistiques, pseudo nombre aléatoire, dates.): help function\n\nRappel: attention entre l’opérateur d’affectation (=) et l’expression conditionnelle (==).\ngen     x=valeur if y==valeur\nreplace x=valeur if y==valeur\nCréation d’une indicatrice (0,1)\nOn peut rapidement générer des indicatrices (0,1) à partir d’une expression conditionnelle:\nSyntaxe:\ngen x= expression_conditionnelle\nExemple avec la variable rep78. On génère la variable rep2 qui prend la valeur 1 si rep78&gt;3, 0 sinon. Comme il y a des valeurs manquantes dans la variable d’origine, on corrige l’information pour l’indicatrice dont les valeurs manquantes ont été automatiquement affectées à la valeur 0.\n\ngen rep2 = rep78&gt;3\nreplace rep2 = . if rep78==.\ntab rep78 rep2\n\n(5 real changes made, 5 to missing)\n\n    Repair |\n    record |         rep2\n      1978 |         0          1 |     Total\n-----------+----------------------+----------\n         1 |         2          0 |         2 \n         2 |         8          0 |         8 \n         3 |        30          0 |        30 \n         4 |         0         18 |        18 \n         5 |         0         11 |        11 \n-----------+----------------------+----------\n     Total |        40         29 |        69 \n\n\nRemarque: Avec la commande tabulate on peut créer une série d’indicatrices à partir d’une variable catégorielle avec l’option gen(nom_variable)\nSyntaxe:\ntab x, gen(nom_variable)\nExemple avec la variable foreign. Avec tabulate on va générer deux indicatrices: origine1 si foreign=0, et origine2 si foreign=1. Un label à la variable est automatiquement créé indiquant la valeur de la variable d’origine.\n\ntab foreign, gen(origine)\n\ndes origine1 origine2\n\ntab origine1 foreign\ntab origine2 foreign\n\n\n Car origin |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   Domestic |         52       70.27       70.27\n    Foreign |         22       29.73      100.00\n------------+-----------------------------------\n      Total |         74      100.00\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\norigine1        byte    %8.0g                 foreign==Domestic\norigine2        byte    %8.0g                 foreign==Foreign\n\nforeign==D |      Car origin\n   omestic |  Domestic    Foreign |     Total\n-----------+----------------------+----------\n         0 |         0         22 |        22 \n         1 |        52          0 |        52 \n-----------+----------------------+----------\n     Total |        52         22 |        74 \n\nforeign==F |      Car origin\n    oreign |  Domestic    Foreign |     Total\n-----------+----------------------+----------\n         0 |        52          0 |        52 \n         1 |         0         22 |        22 \n-----------+----------------------+----------\n     Total |        52         22 |        74 \n\n\n\n\n5.3.2 egen\negen: extented generate\negenmore: package programmé par NJ.Cox qui ajoute des fonctions associée à egen [ssc install egenmore]. On utilise la commande egen une fois le package installé.\nRéservé à l’utilisation de fonctions. Pour obtenir la liste help egen ou help egenmore.\nExemple: on va créer dans un premier la variable mprice qui reporte pour chaque observation la moyenne de la variable price. Dans un second temps, on va créer la variable mprice_or, mais avec le prix moyen des voitures selon leur origine (foreign). La fonction utilisée est la fonction mean().\n\negen mprice = mean(price)\n\nlist  make price mprice in 1/10\n\n\n     +--------------------------+\n     | make    price     mprice |\n     |--------------------------|\n  1. | AMC     4,099   6165.257 |\n  2. | AMC     4,749   6165.257 |\n  3. | AMC     3,799   6165.257 |\n  4. | Bui     4,816   6165.257 |\n  5. | Bui     7,827   6165.257 |\n     |--------------------------|\n  6. | Bui     5,788   6165.257 |\n  7. | Bui     4,453   6165.257 |\n  8. | Bui     5,189   6165.257 |\n  9. | Bui    10,372   6165.257 |\n 10. | Bui     4,082   6165.257 |\n     +--------------------------+\n\n\n\nbysort foreign: egen mprice_or = mean(price)\n\nlist  make price mprice in 1/5\nlist  make price mprice in 66/70\n\n\n     +-------------------------+\n     | make   price     mprice |\n     |-------------------------|\n  1. | AMC    4,099   6165.257 |\n  2. | AMC    4,749   6165.257 |\n  3. | AMC    3,799   6165.257 |\n  4. | Bui    4,816   6165.257 |\n  5. | Bui    7,827   6165.257 |\n     +-------------------------+\n\n     +-------------------------+\n     | make   price     mprice |\n     |-------------------------|\n 66. | Sub    3,798   6165.257 |\n 67. | Toy    5,899   6165.257 |\n 68. | Toy    3,748   6165.257 |\n 69. | Toy    5,719   6165.257 |\n 70. | VW     7,140   6165.257 |\n     +-------------------------+\n\n\n\n\n\n\n\n\nLes fonctions sum() et total()\n\n\n\nSans aucune justification, la fonction sum() qui permet d’obtenir une somme incrémentale n’est pas associée à egen mais à generate. En revanche la fonction total() est associée à egen. Il faut s’en souvenir.\nExemple: on veut créer un identifiant numérique (variable id) pour chaque voiture (dans la base on a une seule voiture par nom de voiture).\n\ngen x = 1 \ngen id = sum(x)\n\nlist id make in 1/5\nlist id make in 66/70\n\n\n     +-----------+\n     | id   make |\n     |-----------|\n  1. |  1   AMC  |\n  2. |  2   AMC  |\n  3. |  3   AMC  |\n  4. |  4   Bui  |\n  5. |  5   Bui  |\n     +-----------+\n\n     +-----------+\n     | id   make |\n     |-----------|\n 66. | 66   Sub  |\n 67. | 67   Toy  |\n 68. | 68   Toy  |\n 69. | 69   Toy  |\n 70. | 70   VW   |\n     +-----------+\n\n\nSi on veut reporter le nombre total d’observations dans la base (variable N), avec la fonction total:\n\negen N = total(x)\n\nlist id N make in 1/5\nlist id N make in 66/70\n\n\n     +----------------+\n     | id    N   make |\n     |----------------|\n  1. |  1   74   AMC  |\n  2. |  2   74   AMC  |\n  3. |  3   74   AMC  |\n  4. |  4   74   Bui  |\n  5. |  5   74   Bui  |\n     +----------------+\n\n     +----------------+\n     | id    N   make |\n     |----------------|\n 66. | 66   74   Sub  |\n 67. | 67   74   Toy  |\n 68. | 68   74   Toy  |\n 69. | 69   74   Toy  |\n 70. | 70   74   VW   |\n     +----------------+\n\n\n\n\nOn va le voir, ces deux variables qui viennent d’être générées peuvent l’être directement avec des variables internes dites de comptage.\n\n\n\n\n\n\nPackage gegen (M.Caceres)\n\n\n\n\nPour les volumétries dépassant le million d’observations il est fortement conseillé d’utiliser la commande gegen associée au package de Mauricio Caceres gtools:\nhttps://gtools.readthedocs.io/en/latest/\nhttps://mthevenin.github.io/stata_programmation/speedup/gtools.html"
  },
  {
    "objectID": "chapitre5.html#sélection-de-plusieurs-modalités-recodage",
    "href": "chapitre5.html#sélection-de-plusieurs-modalités-recodage",
    "title": "5  Les variables",
    "section": "6.1 Sélection de plusieurs modalités, recodage",
    "text": "6.1 Sélection de plusieurs modalités, recodage\ninlist\nPour sélectionner plusieurs modalités d’une variable dans une expression conditionnelle inlist(variable, valeur1, valeur2,..).\nUtile si la variable n’est pas de type ordinale.\nExemple: gen Y=1 if inlist(X,1,3,6,10) L’expression reste hélas toujours limitée à 10 valeurs pour les variables caractères.\ninrange\nPour sélectionner un intervalle dans une expression inrange(variable, valeur1,valeur2) avec \\(valeur1&lt;valeur2\\).\nExemple: gen Y= inrange(X,5,10) pour obtenir \\(Y=1\\) si \\(50\\leq x\\leq 10\\) 0 sinon.\nrecode\nPermet de changer les valeurs d’une variable numérique:\nrecode variable (anciennes_valeurs=nouvelle_valeur) (ancienne_valeurs=nouvelles_valeur).....\nApplication: recoder la variable foreign 0=&gt;1 et 1=&gt;2."
  },
  {
    "objectID": "chapitre5.html#les-labels",
    "href": "chapitre5.html#les-labels",
    "title": "5  Les variables",
    "section": "6.2 Les labels",
    "text": "6.2 Les labels\nLa création et la modification peut se faire directement viala boite de dialogue du variable manager.\nLabel des variables\nSyntaxe:\nlabel nom_variable \"label\" \nOn peut modifier/écraser un label existant\nExemple:\n\ndes foreign\nlabel variable foreign \"Origine de la voiture\"\ndes foreign\n\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\nforeign         byte    %8.0g      origin     Car origin\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\nforeign         byte    %8.0g      origin     Origine de la voiture\n\n\nLabel sur les modalités des variables\nDeux étapes: la création des label et leurs affectation à une ou plusieurs variables.\nCréation du label: label define\nSyntaxe:\nlabel define nom_label val1 \"label1\" val2 \"label2\"... [,modify]\nExemple variable binaire (0,1) labélisée “No-Yes” avec comme nom de label NY : label define NY 0 \"non\" 1 \"oui\nS’il y a beaucoup de modalités à labelliser, on peut affecter ligne par ligne un label par modalité et utiliser l’option modify\nSyntaxe:\nlabel define nom_label 1 \"nom1\", modify\nlabel define nom_label 2 \"nom2\", modify\nlabel define nom_label 3 \"nom3\", modify\nlabel define nom_label 4 \"nom2\", modify\nAffectation du label: label value\nSyntaxe:\nlabel value nom_variable nom_label\nExercice: créer une variable indicatrice qui regroupe de la variable rep78: 0 si rep78&lt;4 et 1 si rep78&gt;3. Affecter un label à la variable (au choix) et des labels aux modalités (au choix).\n\n#| code-fold: true\n#| code-summary: \"Show the code\"\n\ngen rep78b = rep78&lt;4\nreplace rep78b=. if rep78==.\n\nlabel define rep78b 0 \"1-3 réparations\" 1 \"Plus de 3 réparations\", modify\nlabel value rep78b rep78b\ndes rep78b\ntab rep78 rep78b\n\nUnknown #command\nUnknown #command\n\n\n(5 real changes made, 5 to missing)\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------------------\nrep78b          float   %22.0g     rep78b     \n\n    Repair |\n    record |        rep78b\n      1978 | 1-3 répar  Plus de 3 |     Total\n-----------+----------------------+----------\n         1 |         0          2 |         2 \n         2 |         0          8 |         8 \n         3 |         0         30 |        30 \n         4 |        18          0 |        18 \n         5 |        11          0 |        11 \n-----------+----------------------+----------\n     Total |        29         40 |        69 \n\n\nFichiers de labels et multilangue\nlabel save\nOn peut générer un fichier (.do) donnant le programme qui génère les labels (existants) d’une base: commande label save (par le menu: data =&gt; data utilities =&gt; label utilities =&gt; save labels as do file).\nmultilangue\nPour des enquêtes internationales, on peut générer des jeux de labels en plusieurs langues et switcher de l’une à l’autre (exemple MAFE l’Ined). La commande doit être installée, elle est externe à Stata (ssc install mlanguage - auteur J.Weesie).\n::: callout_note ## TODO Faire un rapide topo sur les variables de type dates"
  },
  {
    "objectID": "chapitre6.html#fusion-de-bases",
    "href": "chapitre6.html#fusion-de-bases",
    "title": "6  Manipulations des bases de données",
    "section": "6.1 Fusion de bases",
    "text": "6.1 Fusion de bases\n\nDeux types de fusions:\n\nLa fusion verticale non controlée - empilement - (append)\nla fusion horizontale contrôlée - appariement - (merge).\n\n\n\n6.1.1 Append\n\nConsiste simplement à ajouter des observations entre plusieurs bases, avec ou non un même jeu de variables.\n\n\n\n\n\n\nOn va générer les deux bases de données avec la commande input (non traité dans cette formation: help input).\n\nclear \ninput str6 id v1 v2\n  \"A\" 8 2 \n  \"B\" 1 2 \n  \"C\" 2 4\nend\n\nlist\n\nsave base1, replace\n\n\n\n\n\n\n\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n     +--------------+\nfile base1.dta saved\n\n\n\nclear \ninput str20 id v1 v2 v3\n  \"D\" 2 5 10\n  \"E\" 12 1 8 \nend\nlist\n\nsave base2, replace\n\n\n\n\n\n     +-------------------+\n     | id   v1   v2   v3 |\n     |-------------------|\n  1. |  D    2    5   10 |\n  2. |  E   12    1    8 |\n     +-------------------+\nfile base2.dta saved\n\n\nLa syntaxe de la commande append consiste à ajouter une ou plusieurs bases à la base active avec l’argument using.\n\nappend using base1\nsort id\nlist\n\n\n     +-------------------+\n     | id   v1   v2   v3 |\n     |-------------------|\n  1. |  A    8    2    . |\n  2. |  B    1    2    . |\n  3. |  C    2    4    . |\n  4. |  D    2    5   10 |\n  5. |  E   12    1    8 |\n     +-------------------+\n\n\nOn peut sélectionner les variables de la base qui sera empilée à la base active avec l’option keep.\nDans l’exemple, si la base active est base1, on peut ne pas vouloir ajouter la variable v3 seulement renseignée pour les observations de base2.\n\nuse base1, clear\nappend using base2, keep(id v1 v2)\nlist \n\n(variable id was str6, now str20 to accommodate using data's values)\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n  4. |  D    2    5 |\n  5. |  E   12    1 |\n     +--------------+\n\n\nSi les informations précédentes étaient ventilées dans trois bases, une par variable v, et avec le même niveau d’observation (A,B,C,D,E dans les 3 bases), l’utilisation de append conduirait à une structure empilée non souhaitable avec une réplication des id.\nPour obtenir la base finale proprement appariée, il convient de faire une fusion horizontale contrôlée par une une clé d’identification.\n\n\n6.1.2 Merge\nStata demande que les bases soient soit triées (sort) sur la clé d’appariement en amont de l’opération. Sinon un message d’erreur sera renvoyé.\n\nLa base active (ouverte) est appelée base master\nLa base qui sera appariée à la base ouverte est appelée base using 1\n\nSyntaxe minimale 1 avec préfixes:\nmerge [1:1] [1:m] [m:1] id_variables(s) using nom_base\n\nIci on peut apparier plus de deux bases.\nOn dispose d’une sécurité si les niveaux d’identification sont différents.\n\n\n6.1.2.1 Même niveau d’identification\nPartons des informations suivantes: - Base1 comprend la variable d’identification id (observations A,B,C) et de deux variables numériques v1 et v3 - Base2 comprend la même variable d’identification id (observations B,C,D) et de la variable numérique v3\n Le niveau d’identification est identique dans les deux bases. Il s’agit donc d’un merge 1:1 [One to One]\nOn va de nouveau générer les bases avec input.\n\nclear \ninput str1 id v1 v2 \n\"A\" 8 2 \n\"B\" 1 2\n\"C\" 2 4 \nend\nlist\n\nsort id\nsave base1, replace\n\n\n\n\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n     +--------------+\nfile base1.dta saved\n\n\nRappel: bien faire le sort sur la base using\n\nclear\ninput str1 id v3 \n\"B\" 10 \n\"C\" 8\n\"D\" 10 \nend\nlist\n\nsort id\nsave base2, replace \n\n\n\n\n\n     +---------+\n     | id   v3 |\n     |---------|\n  1. |  B   10 |\n  2. |  C    8 |\n  3. |  D   10 |\n     +---------+\nfile base2.dta saved\n\n\n\nmerge 1:1 id using base1\n\n\n    Result                      Number of obs\n    -----------------------------------------\n    Not matched                             2\n        from master                         1  (_merge==1)\n        from using                          1  (_merge==2)\n\n    Matched                                 2  (_merge==3)\n    -----------------------------------------\n\n\n\nL’output affiche le résultat de l’appariement à l’aide d’un t ltrer si nécessaire les observations selon le résultat de l’apariement. Contrairement à d’autres applications, cette opération n’est pas effectuée en amont avec des fonctions où des options spécifiques. Par exemple avec R: left_join, right_join, inner_join. _merge = 1 : observations qui se trouvent seulement dans la base active (master) _merge = 2 : observations qui se trouvent seulement dans la base using (appariée) _merge = 3 : observations communes aux bases master et using.\nLes variables de la base master/active sont positionnées en tête de colonnes.\n\n\nsort id\nlist\n\n\n     +-------------------------------------+\n     | id   v3   v1   v2            _merge |\n     |-------------------------------------|\n  1. |  A    .    8    2    Using only (2) |\n  2. |  B   10    1    2       Matched (3) |\n  3. |  C    8    2    4       Matched (3) |\n  4. |  D   10    .    .   Master only (1) |\n     +-------------------------------------+\n\n\nSi on souhaite seulement conserver les observations communes aux deux bases (_merge=3):\n\nkeep if _merge==3\nlist\n\n(2 observations deleted)\n\n     +---------------------------------+\n     | id   v3   v1   v2        _merge |\n     |---------------------------------|\n  1. |  B   10    1    2   Matched (3) |\n  2. |  C    8    2    4   Matched (3) |\n     +---------------------------------+\n\n\n\n\n\n\n\n\nVariable _merge et appariements successifs\n\n\n\nPensez à supprimer la variable *_merge* si plusieurs opérations d’appariement sont effectués. La commande ne prévoit pas d’écraser la variable de la fusion précédente.\n\n\nSituation avec plus d’une base à apparier\nOn ne peux pas utiliser la syntaxe avec préfixe (ici merge 1:1).\nOn va ajouter une nouvelle base qui sera appariée avec les deux premières, qui seront donc les deux bases de type using.\n\nclear\ninput str1 id str3  v4 \n\"A\" \"Non\" \n\"B\" \"Oui\" \n\"C\" \"Oui\" \nend\n\nlist \n\nsort id\n\n\n\n\n\n     +----------+\n     | id    v4 |\n     |----------|\n  1. |  A   Non |\n  2. |  B   Oui |\n  3. |  C   Oui |\n     +----------+\n\n\n\nmerge id using base1 base2\n\norder id v1 v2 v3 v4 _merge1 _merge2 _merge \n\nlist\n\n(you are using old merge syntax; see [D] merge for new syntax)\n\n     +------------------------------------------------------+\n     | id   v1   v2   v3    v4   _merge1   _merge2   _merge |\n     |------------------------------------------------------|\n  1. |  A    8    2    .   Non         1         0        3 |\n  2. |  B    1    2   10   Oui         1         1        3 |\n  3. |  C    2    4    8   Oui         1         1        3 |\n  4. |  D    .    .   10               0         1        2 |\n     +------------------------------------------------------+\n\n\nOn obtient maintenant 3 variables _merge:\n\n*_merge1. Donne le résultat de l’appariement entre la nouvelle base et base1*: 0 si seulement dans une seule des deux bases (D), 1 si dans les deux bases (A,B,C).\n*_merge2. Donne le résultat de l’appariement entre la nouvelle base et base2*: 0 si seulement dans une seule des deux bases (A,D), 1 si dans les deux bases (B,C).\n*_merge*. Résume rapidement le matching entre les bases: on retrouve au moins une fois les observations (A,B,C) dans l’un des deux appariement (_merge=3), on trouve une observation (D) qui ne se trouve que dans une base using (_D_merge=2).\n\nSi l’on souhaite conserver les observations communes aux trois bases, on peut sommer les valeurs de *_merge1* et *_merge2* et conserver les observations dont la valeurs de cette somme est égale au nombre d’appariements; ou faire une sélection des observations avec un filtre conditionnel, ici:\n\nkeep if _merge1==1 & _merge2==1\nlist\n\ndrop _merge*\n\n(2 observations deleted)\n\n     +------------------------------------------------------+\n     | id   v1   v2   v3    v4   _merge1   _merge2   _merge |\n     |------------------------------------------------------|\n  1. |  B    1    2   10   Oui         1         1        3 |\n  2. |  C    2    4    8   Oui         1         1        3 |\n     +------------------------------------------------------+\n\n\n\n\n\n\n\n\nCommande join du package ftools\n\n\n\n[A tester]\n\nDocumentation.\nPermet de gagner 70% de durée d’exécution lorsque la volumétrie dépasse 100000 observations\nGère en amont le tri des bases appariée.\n\n\n\n\n\n6.1.2.2 Niveaux d’identification différents\nUn merge de type 1:1 n’est pas possible. Dans l’exemple qui suit la base period_act liste pour deux personnes le statut d’activité observé pour plusieurs périodes soit des observations multiples pour chaque individus, et la base sexe donne une caractéristique unique pour chaque individu. Selon le statut des bases appariée (master ou using), l’appariement est de type 1:m ou m:1.\n\nSi la base active est à observations multiples sur la clé d’identification: m:1\nSi la base active est à observations uniques sur la clé d’identification: 1:m\n\n\n\n\n\n\nOn va de nouveau générer les données avec input\n\nclear \ninput id périodes str8 Activité\n1 1 \"Emploi\"\n1 2 \"Emploi\"\n1 3 \"Chômage\"\n2 1 \"Chômage\" \n2 2 \"Chômage\"\n2 3 \"Emploi\"\n2 4 \"Chômage\" \nend \nlist \nsort id \nsave \"period_act\", replace\n\n\n\n\n\n     +--------------------------+\n     | id   périodes   Activité |\n     |--------------------------|\n  1. |  1          1     Emploi |\n  2. |  1          2     Emploi |\n  3. |  1          3    Chômage |\n  4. |  2          1    Chômage |\n  5. |  2          2    Chômage |\n     |--------------------------|\n  6. |  2          3     Emploi |\n  7. |  2          4    Chômage |\n     +--------------------------+\nfile period_act.dta saved\n\n\n\nclear\ninput id str6 sexe \n1 \"Homme\"  \n2 \"Femme\"  \nend \nlist\nsort id \nsave \"sexe\", replace\n\n\n\n\n\n     +------------+\n     | id    sexe |\n     |------------|\n  1. |  1   Homme |\n  2. |  2   Femme |\n     +------------+\nfile sexe.dta saved\n\n\nSi on effectuait un merge 1:1, Stata renverrait le message d’erreur suivant:\nmerge 1:1 id using activités\n\nvariable id does not uniquely identify observations in the using data\nr(459);\nIci la base active est la base sex. Le prefixe qui doit être utilisé est donc 1:m 2\n\nmerge 1:m id using period_act\nsort id période\nlist \n\n\n    Result                      Number of obs\n    -----------------------------------------\n    Not matched                             0\n    Matched                                 7  (_merge==3)\n    -----------------------------------------\n\n     +------------------------------------------------+\n     | id    sexe   périodes   Activité        _merge |\n     |------------------------------------------------|\n  1. |  1   Homme          1     Emploi   Matched (3) |\n  2. |  1   Homme          2     Emploi   Matched (3) |\n  3. |  1   Homme          3    Chômage   Matched (3) |\n  4. |  2   Femme          1    Chômage   Matched (3) |\n  5. |  2   Femme          2    Chômage   Matched (3) |\n     |------------------------------------------------|\n  6. |  2   Femme          3     Emploi   Matched (3) |\n  7. |  2   Femme          4    Chômage   Matched (3) |\n     +------------------------------------------------+\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nLe tri de la base est régulièrement modifié après ce type d’appariement. Penser donc à retrier les données proprement, surtout quand il s’agit comme ici d’informations biographiques (sort id périodes)\n\n\nDe nouveau les préfixes sont optionnels, et permettent seulement de contrôler l’appariement. On peut sans soucis fusionner des informations contextuelles avec des informations multiples avec seulement merge. Un avertissement se renvoyé à l’exécution de la commande\n\nuse sexe, clear\nmerge id using period_act\nsort id périodes\nlist\n\n(you are using old merge syntax; see [D] merge for new syntax)\nvariable id does not uniquely identify observations in period_act.dta\n\n     +-------------------------------------------+\n     | id    sexe   périodes   Activité   _merge |\n     |-------------------------------------------|\n  1. |  1   Homme          1     Emploi        3 |\n  2. |  1   Homme          2     Emploi        3 |\n  3. |  1   Homme          3    Chômage        3 |\n  4. |  2   Femme          1    Chômage        3 |\n  5. |  2   Femme          2    Chômage        3 |\n     |-------------------------------------------|\n  6. |  2   Femme          3     Emploi        3 |\n  7. |  2   Femme          4    Chômage        3 |\n     +-------------------------------------------+\n\n\n\n\n6.1.2.3 Appariement avec des frames\nL’utilisation des frames présentent plusieurs avantages:\n\nIl n’est pas nécessaire de trier les bases concernées par l’appariement.\nOn peut sélectionner avec la commande frget la ou les variables qui seront récupérées dans la base master. On apparie donc pas des bases en tant que telles, on récupère de l’information de frames liées.\nMieux encore, on peut réaliser des opérations entre observations individuelles et observations contextuelles sans passer par un appariement. Avec les frames, l’opération d’appariement doit être plutôt compris comme un système de liaison entre bases, le transfert d’informations n’étant qu’une opération optionnelle.\n\nAu niveau des désavantages:\n\nSi on ne travaille pas exclusivement sous frames, les bases devront être transformées en frame (voir exemple)\nAbsence de variable de type *_merge* qui permet de contrôler le résultat de l’appariement.\nles prefixes sont uniquement 1:1 et m:1. Cela signifie dans le second cas que la frame active lors de l’opération de liaison doit toujours être celle dont la clé d’identification est de type multiple (niveau individuel).\nPeut-être le plus embêtant est l’absence d’appariement pour les informations correspondant à **_merge=2** (Informations seulement présentes dans la base using). Le dernier exemple illustre ce point.\n\nOn reprend l’exemple précédent, en transformant dans un premier temps les deux bases en frames.\n\nframe reset\n\nframe create period_act\nframe period_act: use period_act\nframe create sexe\nframe sexe: use sexe\n\nframe dir\n\n  default     0 x 0\n  period_act  7 x 3; period_act.dta\n  sexe        2 x 2; sexe.dta\n\n\nOn doit se positionner sur la frame period_act (type m)\n\nframe change period_act\n\nPour lier les frames on utilise la commande frlink.\nSyntaxe\nfrlink 1:1/m:1 id_variable(s), frame(nom_frame) gen(variable_lien)\nIci on fait un appariement de type m:1, la clé d’identification est de nouveau id. On lie la frame active à la frame sexe et la variable de liaison (ici un alias de la variable id) est appelée link.\n\nfrlink m:1 id, frame(sexe) gen(link)\n\n(all observations in frame period_act matched)\n\n\nPour importer la variable sexe dans la frame period_act, on utilise la commande frget, en précisant la ou les variable que l’on souhaite récupérer, ainsi que la variable de liaison (une même frame peut avoir plusieurs liaisons. Voir plus loin).\n\nfrget sexe , from(link)\n\nframe period_act: order link, last\nlist\n\n(1 variable copied from linked frame)\n\n     +-----------------------------------------+\n     | id   périodes   Activité    sexe   link |\n     |-----------------------------------------|\n  1. |  1          1     Emploi   Homme      1 |\n  2. |  1          2     Emploi   Homme      1 |\n  3. |  1          3    Chômage   Homme      1 |\n  4. |  2          1    Chômage   Femme      2 |\n  5. |  2          2    Chômage   Femme      2 |\n     |-----------------------------------------|\n  6. |  2          3     Emploi   Femme      2 |\n  7. |  2          4    Chômage   Femme      2 |\n     +-----------------------------------------+\n\n\n\n\n\n\n\n\nLiaison des frames en présence d’information incomplète\n\n\n\nLa liaison de frames peut être problématique en présence d’informations incomplètes. Pour faire simple, la liaison des frames permet de faire des appariements de type **_merge=1** et **_merge=3** (présence dans la master seulement ou présence dans la master et la using) mais ne permet pas de récupérer des informations présentes seulement dans la base using).\nPour illustrer cela on va générer une nouvelle frame, de type individus-périodes, avec une variable additionnelle tvc.\n\nPour id= 1, on a pas d’information dans la frame period_act pour période=4.\nPour id= 2, on a pas d’information dans la frame tvc pour les périodes 3 et 4.\n\nCréation de la nouvelle frame (voir le .do, la compilation pour générer ce support complexifie un peu l’opération):\n\nframe create tvc\nframe change tvc\n\n\nclear\ninput id périodes tvc \n1 1 0   \n1 2 0   \n1 3 1  \n1 4 0  \n2 1 1  \n2 2 0 \nend\n\nlist \n\nsave tvc, replace\nframe tvc: use tvc\n\n\n\n\n\n     +---------------------+\n     | id   périodes   tvc |\n     |---------------------|\n  1. |  1          1     0 |\n  2. |  1          2     0 |\n  3. |  1          3     1 |\n  4. |  1          4     0 |\n  5. |  2          1     1 |\n     |---------------------|\n  6. |  2          2     0 |\n     +---------------------+\nfile tvc.dta saved\n\n\nLiaison des frames et récupération de la variable tvc dans period_act\n\nframe change period_act\nfrlink 1:1 id périodes, frame(tvc) gen(link2)\n\nfrget tvc, from(link2)\n\nlist\n\n(2 observations in frame period_act unmatched)\n(2 missing values generated)\n(1 variable copied from linked frame)\n\n     +-------------------------------------------------------+\n     | id   périodes   Activité    sexe   link   link2   tvc |\n     |-------------------------------------------------------|\n  1. |  1          1     Emploi   Homme      1       1     0 |\n  2. |  1          2     Emploi   Homme      1       2     0 |\n  3. |  1          3    Chômage   Homme      1       3     1 |\n  4. |  2          1    Chômage   Femme      2       5     1 |\n  5. |  2          2    Chômage   Femme      2       6     0 |\n     |-------------------------------------------------------|\n  6. |  2          3     Emploi   Femme      2       .     . |\n  7. |  2          4    Chômage   Femme      2       .     . |\n     +-------------------------------------------------------+\n\n\nOn voit bien que la valeur de tvc pour id=1 et périodes=4 n’a pas été importée (**_merge=2** dans un appariement classique). En revanche, pour id=2, l’incomplétude de l’information dans la base tvc pour les périodes 3 et 4 est bien visible.\nAvec un merge classique (on suppose que period_act n’a pas été appariée à sexe):\n\nuse tvc, clear\nsort id périodes\nsave tvc, replace\nuse period_act, clear\nsort id périodes\nmerge 1:1 id périodes using tvc\nsort id périodes\nlist\n\nfile tvc.dta saved\n\n    Result                      Number of obs\n    -----------------------------------------\n    Not matched                             3\n        from master                         2  (_merge==1)\n        from using                          1  (_merge==2)\n\n    Matched                                 5  (_merge==3)\n    -----------------------------------------\n\n     +--------------------------------------------------+\n     | id   périodes   Activité   tvc            _merge |\n     |--------------------------------------------------|\n  1. |  1          1     Emploi     0       Matched (3) |\n  2. |  1          2     Emploi     0       Matched (3) |\n  3. |  1          3    Chômage     1       Matched (3) |\n  4. |  1          4                0    Using only (2) |\n  5. |  2          1    Chômage     1       Matched (3) |\n     |--------------------------------------------------|\n  6. |  2          2    Chômage     0       Matched (3) |\n  7. |  2          3     Emploi     .   Master only (1) |\n  8. |  2          4    Chômage     .   Master only (1) |\n     +--------------------------------------------------+\n\n\nOn a bien ici l’ajout de l’information correspondant à _merge=2 (Using only)\n\n\nUn des intérêts des frames, est de faire des opérations entre informations individuelles et contextuelles sans passer par un appariement en amont. Par l’exemple, nous allons voir comment un appariement peut être évité lorsqu’on travaille sur ce genre d’information.\nOn va générer 2 bases, une individuelle et une contextuelle. La première contient un identifiant individuel (id), le nom de la zône d’appartenance (zone) et les valeurs observées d’une variable x. La seconde contient le nom des zônes et la valeur moyenne de la variable x dans ces espaces.\nCréation des frames:\n\nframe reset \n\nclear \ninput id str6 zone x\n1 \"zoneA\" 10\n2 \"zoneA\" 15\n3 \"zoneB\" 9\n4 \"zoneB\" 12\n5 \"zoneB\" 10\n6 \"zoneB\" 15\n7 \"zoneC\" 6\n8 \"zoneC\" 13\n9 \"zoneC\" 16\nend\nlist\nsave indiv, replace\n\n\n\n\n\n     +-----------------+\n     | id    zone    x |\n     |-----------------|\n  1. |  1   zoneA   10 |\n  2. |  2   zoneA   15 |\n  3. |  3   zoneB    9 |\n  4. |  4   zoneB   12 |\n  5. |  5   zoneB   10 |\n     |-----------------|\n  6. |  6   zoneB   15 |\n  7. |  7   zoneC    6 |\n  8. |  8   zoneC   13 |\n  9. |  9   zoneC   16 |\n     +-----------------+\nfile indiv.dta saved\n\n\n\nclear\ninput str6 zone xmean\n\"zoneA\" 11\n\"zoneB\" 12\n\"zoneC\" 13\nend\nlist\nsave zone, replace\n\n\n\n\n\n     +---------------+\n     |  zone   xmean |\n     |---------------|\n  1. | zoneA      11 |\n  2. | zoneB      12 |\n  3. | zoneC      13 |\n     +---------------+\nfile zone.dta saved\n\n\n\nframe create indiv\nframe indiv: use indiv\nframe create zone\nframe zone: use zone\n\nAprès avoir lié les deux frames (m:1), on va calculer directement la différence entre la valeur observée pour chaque individu de la variable x et sa moyenne par zone (xmean). On utilise la fonction frval comme argument de la commande generate.\n\nframe change indiv\nfrlink m:1 zone, frame(zone) gen(link)\nlist\n\n(all observations in frame indiv matched)\n\n     +------------------------+\n     | id    zone    x   link |\n     |------------------------|\n  1. |  1   zoneA   10      1 |\n  2. |  2   zoneA   15      1 |\n  3. |  3   zoneB    9      2 |\n  4. |  4   zoneB   12      2 |\n  5. |  5   zoneB   10      2 |\n     |------------------------|\n  6. |  6   zoneB   15      2 |\n  7. |  7   zoneC    6      3 |\n  8. |  8   zoneC   13      3 |\n  9. |  9   zoneC   16      3 |\n     +------------------------+\n\n\ngen = var1 - frval(nom_link, var2)\n\ngen diffx = x - frval(link, xmean)\nlist\n\n\n     +--------------------------------+\n     | id    zone    x   link   diffx |\n     |--------------------------------|\n  1. |  1   zoneA   10      1      -1 |\n  2. |  2   zoneA   15      1       4 |\n  3. |  3   zoneB    9      2      -3 |\n  4. |  4   zoneB   12      2       0 |\n  5. |  5   zoneB   10      2      -2 |\n     |--------------------------------|\n  6. |  6   zoneB   15      2       3 |\n  7. |  7   zoneC    6      3      -7 |\n  8. |  8   zoneC   13      3       0 |\n  9. |  9   zoneC   16      3       3 |\n     +--------------------------------+"
  },
  {
    "objectID": "chapitre6.html#transposition-dune-base",
    "href": "chapitre6.html#transposition-dune-base",
    "title": "6  Manipulations des bases de données",
    "section": "6.2 Transposition d’une base",
    "text": "6.2 Transposition d’une base\n\n6.2.1 Syntaxe et exemples\nCette opération permet d’allonger ou d’élargir une base, généralement sur des variables occurencées. Ces occurences peuvent être des séquences ou points chronologiques (valeur d’une variable sur plusieurs années), ou des individus composant un ménage.\nAvec Stata, ces opérations de transpositions sont effectuées avec la commande reshape\n\nDe large à long: reshape long\nDe long à large: reshape wide\n\nA noter que la seconde opération est plus gourmande en durée d’exécution. De nouveau si la volumétrie de la base est élevée, disons plus d’une million d’observations, on peut se reporter sur la commande greshape du package gtools. On peut trouver un benchmark sur des données simulées [liens].\nAu niveau de la syntaxe:\n\nIl est nécessaire d’avoir une variable d’identification pour réaliser l’opération: cela peut être un identifiant individuel3 si la variations des observations est relatives à des périodes, ou un identifiant ménage si la source de la variation sont les personnes le composant. Ce peut bien évidemment fonctionner avec des zônes géographiques: régions-départements, régions-communes, départements-communes.\nCette variable d’identification doit être renseignée en option: i(var_id)\nOn indique dans l’expression principale le racine des variables occurencées: si la base est en format large avec les variables revenu1980, revenu1981,….,revenu1990, la racine sera donc revenu. Les occurences peuvent être des lettres (A,B,D…) ou des mots (un,deux,trois…).\nInformation sur les occurences: selon le type de transposition on doit indiquer en option la variable qui contiendra ou qui contient les occurences. Cette option est j(nom_variable)\n\nsi la base est en format large et qu’on souhaite l’allonger, on indique obligatoirement la variable qui sera créée et qui reportera les valeurs des occurences.\nsi la base est en format long et qu’on souhaite l’élargir, on indique obligatoirement la variable qui contient les occurences.\n\nSelon la transposition, le nom de commande est suivi de long ou wide\n\nSyntaxe de large à long:\nreshape long racines_variables_occurencées, i(var_id) j(var_occurences)\nSyntaxe de long à large:\nreshape wide racines_variables_occurencées, i(var_id) j(var_occurences)\nExemple\nOn part de la base suivante\n\nclear \ninput id x1 x2 x3 x4\n1 10 20 12 25\n2 12 22 15 30\n3 15 25 33 30\n4 21 17 22 27\n5 13 15 14 18\nend\n\nlist\n\n\n\n\n\n     +------------------------+\n     | id   x1   x2   x3   x4 |\n     |------------------------|\n  1. |  1   10   20   12   25 |\n  2. |  2   12   22   15   30 |\n  3. |  3   15   25   33   30 |\n  4. |  4   21   17   22   27 |\n  5. |  5   13   15   14   18 |\n     +------------------------+\n\n\nOn allonger la base sur les variables x1 à x4. La racine est donc x. Pour le choix de la nouvelle variable qui aura pour chaque id les valeurs 1 à 4, on ne peux pas choisir x, qui sera créée automatiquement. Selon le type d’information contenu dans l’occurence, on peut utiliser un nom indiquant une période, un membre de ménage ou une zône géographique. Ici on ca suposer que les occurences sont de nature temporelle, et on choisira t comme nom à la variable de l’option j().\n\nreshape long x , i(id) j(t)\n\n(j = 1 2 3 4)\n\nData                               Wide   -&gt;   Long\n-----------------------------------------------------------------------------\nNumber of observations                5   -&gt;   20          \nNumber of variables                   5   -&gt;   3           \nj variable (4 values)                     -&gt;   t\nxij variables:\n                           x1 x2 ... x4   -&gt;   x\n-----------------------------------------------------------------------------\n\n\nOn remarque que Stata donne quelques informations sur le résultats de l’opération: variables créées, nombre d’observations dans le nouveau format\n\nlist\n\n\n     +-------------+\n     | id   t    x |\n     |-------------|\n  1. |  1   1   10 |\n  2. |  1   2   20 |\n  3. |  1   3   12 |\n  4. |  1   4   25 |\n  5. |  2   1   12 |\n     |-------------|\n  6. |  2   2   22 |\n  7. |  2   3   15 |\n  8. |  2   4   30 |\n  9. |  3   1   15 |\n 10. |  3   2   25 |\n     |-------------|\n 11. |  3   3   33 |\n 12. |  3   4   30 |\n 13. |  4   1   21 |\n 14. |  4   2   17 |\n 15. |  4   3   22 |\n     |-------------|\n 16. |  4   4   27 |\n 17. |  5   1   13 |\n 18. |  5   2   15 |\n 19. |  5   3   14 |\n 20. |  5   4   18 |\n     +-------------+\n\n\nOn peut repasser au format de départ (large) avec reshape wide\n\nreshape wide x , i(id) j(t)\n\n(j = 1 2 3 4)\n\n\n\nData                               Long   -&gt;   Wide\n-----------------------------------------------------------------------------\nNumber of observations               20   -&gt;   5           \nNumber of variables                   3   -&gt;   5           \nj variable (4 values)                 t   -&gt;   (dropped)\nxij variables:\n                                      x   -&gt;   x1 x2 ... x4\n-----------------------------------------------------------------------------\n\n\n\nlist\n\n\n     +------------------------+\n     | id   x1   x2   x3   x4 |\n     |------------------------|\n  1. |  1   10   20   12   25 |\n  2. |  2   12   22   15   30 |\n  3. |  3   15   25   33   30 |\n  4. |  4   21   17   22   27 |\n  5. |  5   13   15   14   18 |\n     +------------------------+\n\n\nBien évidemment les variable fixes ne doivent pas être renseigné dans la commande, les valeurs sont conservées\n\nclear \ninput id x1 x2 x3 x4 fixe\n1 10 20 12 25 0\n2 12 22 15 30 1\n3 15 25 33 30 0\n4 21 17 22 27 1\n5 13 15 14 18 0\n\nend\nlist\n\nreshape long x, i(id) j(t)\nlist\n\n\n\n\n\n     +-------------------------------+\n     | id   x1   x2   x3   x4   fixe |\n     |-------------------------------|\n  1. |  1   10   20   12   25      0 |\n  2. |  2   12   22   15   30      1 |\n  3. |  3   15   25   33   30      0 |\n  4. |  4   21   17   22   27      1 |\n  5. |  5   13   15   14   18      0 |\n     +-------------------------------+\n(j = 1 2 3 4)\n\nData                               Wide   -&gt;   Long\n-----------------------------------------------------------------------------\nNumber of observations                5   -&gt;   20          \nNumber of variables                   6   -&gt;   4           \nj variable (4 values)                     -&gt;   t\nxij variables:\n                           x1 x2 ... x4   -&gt;   x\n-----------------------------------------------------------------------------\n\n     +--------------------+\n     | id   t    x   fixe |\n     |--------------------|\n  1. |  1   1   10      0 |\n  2. |  1   2   20      0 |\n  3. |  1   3   12      0 |\n  4. |  1   4   25      0 |\n  5. |  2   1   12      1 |\n     |--------------------|\n  6. |  2   2   22      1 |\n  7. |  2   3   15      1 |\n  8. |  2   4   30      1 |\n  9. |  3   1   15      0 |\n 10. |  3   2   25      0 |\n     |--------------------|\n 11. |  3   3   33      0 |\n 12. |  3   4   30      0 |\n 13. |  4   1   21      1 |\n 14. |  4   2   17      1 |\n 15. |  4   3   22      1 |\n     |--------------------|\n 16. |  4   4   27      1 |\n 17. |  5   1   13      0 |\n 18. |  5   2   15      0 |\n 19. |  5   3   14      0 |\n 20. |  5   4   18      0 |\n     +--------------------+\n\n\n\n\n6.2.2 Mise en garde\nComplétude du nom de la racine\nBien penser à mettre l’intégralité de la racine, partie fixe de la variable occurencée:\n\nclear \ninput id x_1 x_2 x_3 x_4\n1 10 20 12 25\n2 12 22 15 30\n3 15 25 33 30\n4 21 17 22 27\n5 13 15 14 18\nend\n\nlist\n\n\n\n\n\n     +----------------------------+\n     | id   x_1   x_2   x_3   x_4 |\n     |----------------------------|\n  1. |  1    10    20    12    25 |\n  2. |  2    12    22    15    30 |\n  3. |  3    15    25    33    30 |\n  4. |  4    21    17    22    27 |\n  5. |  5    13    15    14    18 |\n     +----------------------------+\n\n\n\nreshape long x , i(id) j(t)\n\nrenverra le message d’erreur suivant:\nvariable t contains all missing values\nr(498);\nOmission de variables occurencée\nContrairement à l’allongement, l’élargissement est plus contraignant, toutes les variables non fixes doivent être renseignées.\nSi on omet des variables occurencées dans l’allongement, elle sont conservées tel quel et les valeurs sont répliquées d’une ligne à l’autre:\n\nclear \ninput id x1 x2 y1 y2 fixe\n1 10 20 12 25 0\n2 12 22 15 30 0\n3 15 25 33 30 1\n4 21 17 22 27 1\n5 13 15 14 18 0\nend\nlist\n\nreshape long x , i(id) j(t)\nlist\n\n\n\n\n\n     +-------------------------------+\n     | id   x1   x2   y1   y2   fixe |\n     |-------------------------------|\n  1. |  1   10   20   12   25      0 |\n  2. |  2   12   22   15   30      0 |\n  3. |  3   15   25   33   30      1 |\n  4. |  4   21   17   22   27      1 |\n  5. |  5   13   15   14   18      0 |\n     +-------------------------------+\n(j = 1 2)\n\nData                               Wide   -&gt;   Long\n-----------------------------------------------------------------------------\nNumber of observations                5   -&gt;   10          \nNumber of variables                   6   -&gt;   6           \nj variable (2 values)                     -&gt;   t\nxij variables:\n                                  x1 x2   -&gt;   x\n-----------------------------------------------------------------------------\n\n     +------------------------------+\n     | id   t    x   y1   y2   fixe |\n     |------------------------------|\n  1. |  1   1   10   12   25      0 |\n  2. |  1   2   20   12   25      0 |\n  3. |  2   1   12   15   30      0 |\n  4. |  2   2   22   15   30      0 |\n  5. |  3   1   15   33   30      1 |\n     |------------------------------|\n  6. |  3   2   25   33   30      1 |\n  7. |  4   1   21   22   27      1 |\n  8. |  4   2   17   22   27      1 |\n  9. |  5   1   13   14   18      0 |\n 10. |  5   2   15   14   18      0 |\n     +------------------------------+\n\n\nEn revanche si on part d’une base longue avec plusieurs dimensions variables\n\n\n\n\n\n(j = 1 2)\n\nData                               Wide   -&gt;   Long\n-----------------------------------------------------------------------------\nNumber of observations                5   -&gt;   10          \nNumber of variables                   6   -&gt;   5           \nj variable (2 values)                     -&gt;   t\nxij variables:\n                                  x1 x2   -&gt;   x\n                                  y1 y2   -&gt;   y\n-----------------------------------------------------------------------------\n\n\n\nlist\n\n\n     +-------------------------+\n     | id   t    x    y   fixe |\n     |-------------------------|\n  1. |  1   1   10   12      0 |\n  2. |  1   2   20   25      0 |\n  3. |  2   1   12   15      0 |\n  4. |  2   2   22   30      0 |\n  5. |  3   1   15   33      1 |\n     |-------------------------|\n  6. |  3   2   25   30      1 |\n  7. |  4   1   21   22      1 |\n  8. |  4   2   17   27      1 |\n  9. |  5   1   13   14      0 |\n 10. |  5   2   15   18      0 |\n     +-------------------------+\n\n\n\nreshape wide x, i(id) j(t)\n\nrenverra le message d’erreur suivant:\n(j = 1 2)\nvariable y not constant within id\nYour data are currently long. You are performing a reshape wide. You typed something like\n\n. reshape wide a b, i(id) j(t)\n\n    There are variables other than a, b, id, t in your data. They must be constant within id because that is the only way they can fit into wide data without loss\n    of information.\n\n    The variable or variables listed above are not constant within id. Perhaps the values are in error. Type reshape error for a list of the problem observations.\n\n    Either that, or the values vary because they should vary, in which case you must either add the variables to the list of xij variables to be reshaped, or drop them."
  },
  {
    "objectID": "chapitre6.html#allongement-dune-base",
    "href": "chapitre6.html#allongement-dune-base",
    "title": "6  Manipulations des bases de données",
    "section": "6.3 Allongement d’une base",
    "text": "6.3 Allongement d’une base\nSection très courte. Pariculièrement utile lorsqu’on manipule des données biographiques avec des durées, et pour faire la mise en forme nécessaire pour une analyse à durée discrète. La commande expand permet de répliquer les lignes, sur une valeur fixe qu’on indique ou sur des valeurs non constantes renseignés dans une variable.\nDans le premier cas la syntaxe est: expand valeur Dans le second cas la synataxe est: expand nom_variable\nExemple:\n\nclear \ninput id duree e\n1  3 0 \n2  4 1\n3  2 1 \nend\n\nlist\n\n\n\n\n\n     +----------------+\n     | id   duree   e |\n     |----------------|\n  1. |  1       3   0 |\n  2. |  2       4   1 |\n  3. |  3       2   1 |\n     +----------------+\n\n\nAllongement de la base:\n\nexpand duree\n\n(6 observations created)\n\n\nSi on veut faire une analyse à durée discrère, avec les variables de comptage (chapitre 5):\n\nbysort id: gen t=_n\nbysort id: replace e=0 if t&lt;_N\nlist\n\n(4 real changes made)\n\n     +--------------------+\n     | id   duree   e   t |\n     |--------------------|\n  1. |  1       3   0   1 |\n  2. |  1       3   0   2 |\n  3. |  1       3   0   3 |\n  4. |  2       4   0   1 |\n  5. |  2       4   0   2 |\n     |--------------------|\n  6. |  2       4   0   3 |\n  7. |  2       4   1   4 |\n  8. |  3       2   0   1 |\n  9. |  3       2   1   2 |\n     +--------------------+\n\n\nRemarque: si la valeur sur laquelle est allongée la base a une valeur négative (par exemple des durées négatives), un message indique leur présence."
  },
  {
    "objectID": "chapitre6.html#créer-des-bases-dindicateurs",
    "href": "chapitre6.html#créer-des-bases-dindicateurs",
    "title": "6  Manipulations des bases de données",
    "section": "6.4 Créer des bases d’indicateurs",
    "text": "6.4 Créer des bases d’indicateurs\nDans ce qui suit il est fortement recommandé d’utiliser les frames (Stata 16 minimum). Pour faire ce type d’opérations deux commandes sont disponibles:\n\nla plus utilisée, collapse permet de créer une base d’indicateurs dédiées aux variables quantitatives: moyenne, médiane et autes quantiles, ….\nla moins utilisée, contract, est dédiée aux variables catégorielles (effectifs et effectif cumulés, proportions et proportions cumulées).\n\nPour les pondérations admises, se reporter à l’aide des commandes4.\n\n\n\n\n\n\nEcrasement de la base d’origine\n\n\n\nAttention la base sur laquelle on travaille va être écrasée. Si ce n’est pas souhaité:\n\nUtiliser les commandes preserve restore avant et après l’opération.\nGénérer une frame avec les variables qui seront transformées en indicateurs. On pourra conserver les deux bases dans la sessions, et les utiliser en parallèle.\n\n\n\n\n6.4.1 collapse\nLes indicateurs disponibles sont les suivants:\n        mean         means (default)\n        median       medians\n        p1           1st percentile\n        p2           2nd percentile\n        ...          3rd-49th percentiles\n        p50          50th percentile (same as median)\n        ...          51st-97th percentiles\n        p98          98th percentile\n        p99          99th percentile\n        sd           standard deviations\n        semean       standard error of the mean (sd/sqrt(n))\n        sebinomial   standard error of the mean, binomial (sqrt(p(1-p)/n))\n        sepoisson    standard error of the mean, Poisson (sqrt(mean/n))\n        sum          sums\n        rawsum       sums, ignoring optionally specified weight except observations with a weight of zero are excluded\n        count        number of nonmissing observations\n        percent      percentage of nonmissing observations\n        max          maximums\n        min          minimums\n        iqr          interquartile range\n        first        first value\n        last         last value\n        firstnm      first nonmissing value\n        lastnm       last nonmissing value\n\nPar défaut c’est la moyenne qui est utilisée.\nLes résultats peuvent être stratifiées avec une option by().\n\nSyntaxe avec un seul indicateur\n\ncollapse [(statistique autre que moyenne) varlist [, by(varlist)] \n\nDans les exemples, on utilisera preserve restore pour retrouver la base de départ.\nExemples\n\nclear\nsysuse auto\n\npreserve \ncollapse price\nlist\nrestore\n\npreserve \ncollapse price mpg, by(foreign)\nlist\nrestore\n\npreserve \ncollapse (median) price mpg, by(foreign)\nlist\nrestore\n\npreserve \ncollapse (median) price mpg if rep78!=., by(foreign rep78)\nlist\nrestore\n\n(Note: Below code run with echo to enable preserve/restore functionality.)\n\n. clear\n\n. sysuse auto\n(1978 automobile data)\n\n. preserve\n\n. collapse price\n\n. list\n\n     +---------+\n     |   price |\n     |---------|\n  1. | 6,165.3 |\n     +---------+\n\n. restore\n\n. preserve\n\n. collapse price mpg, by(foreign)\n\n. list\n\n     +------------------------------+\n     |  foreign     price       mpg |\n     |------------------------------|\n  1. | Domestic   6,072.4   19.8269 |\n  2. |  Foreign   6,384.7   24.7727 |\n     +------------------------------+\n\n. restore\n\n. preserve\n\n. collapse (median) price mpg, by(foreign)\n\n\n\n. list\n\n     +---------------------------+\n     |  foreign     price    mpg |\n     |---------------------------|\n  1. | Domestic   4,782.5     19 |\n  2. |  Foreign     5,759   24.5 |\n     +---------------------------+\n\n. restore\n\n. preserve\n\n. collapse (median) price mpg if rep78!=., by(foreign rep78)\n\n. list\n\n     +----------------------------------+\n     | rep78    foreign     price   mpg |\n     |----------------------------------|\n  1. |     1   Domestic   4,564.5    21 |\n  2. |     2   Domestic     4,638    18 |\n  3. |     3   Domestic     4,749    19 |\n  4. |     4   Domestic     5,705    18 |\n  5. |     5   Domestic   4,204.5    32 |\n     |----------------------------------|\n  6. |     3    Foreign     4,296    23 |\n  7. |     4    Foreign     6,229    25 |\n  8. |     5    Foreign     5,719    25 |\n     +----------------------------------+\n\n. restore\n\n. \n\n\nOn voit que la variable indicateur prend le nom de la variable. On ne peut donc pas générer une liste d’indicateurs sans renommer les variables.\nSyntaxe avec plusieurs indicateurs\nDans l’expression principal, on doit donner un nom différent à chaque variable pour chaque indicateur…ce n’est pas très pratique, Stata aurait pu prévoir un moyen de générer par défaut des nom de variable comme mean_varname, min_varname….\nDans le cas de deux indicateurs (median, min) pour deux variable (price, mpg).\n\ncollapse [(stat1) varname11 = var1 varname21= var2  (stat2 ) varname12 = var1 varname22= var2 [, by(varlist)] \n\n\npreserve\ncollapse (median) pricemed = price mpgmed=mpg  (min) pricemin = price mpgmin= mpg , by(foreign)\nlist\nrestore\n\n(Note: Below code run with echo to enable preserve/restore functionality.)\n\n. preserve\n\n. collapse (median) pricemed = price mpgmed=mpg (min) pricemin = price mpgmin= \n&gt; mpg , by(foreign)\n\n. list\n\n     +--------------------------------------------------+\n     |  foreign   pricemed   mpgmed   pricemin   mpgmin |\n     |--------------------------------------------------|\n  1. | Domestic    4,782.5       19      3,291       12 |\n  2. |  Foreign      5,759     24.5      3,748       14 |\n     +--------------------------------------------------+\n\n. restore\n\n. \n\n\nRemarque: pour des variables codées sous forme d’indicatrice, on peut générer des proportions ou des pourcentages facilement, ce qui rend la commande contract caduque avec deux modalités (exemple: variable foreign).\n\n\n6.4.2 contract\nMême principe, mais le nombre d’indicateurs est limité (effectifs ou proportion, cumulées ou non). Il n’y a pas d’option by mais on peut directement croiser les dimensions avec plusieurs variables. Je n’ai jamais utilisé cette commande en dehors de la formation, donc je n’en donnerai que deux exemples:\n\npreserve \ncontract rep78 foreign \nlist\nrestore\n\n\npreserve \ncontract rep78 foreign,  percent(percentage) \nlist\nrestore\n\n(Note: Below code run with echo to enable preserve/restore functionality.)\n\n. preserve\n\n. contract rep78 foreign\n\n. list\n\n     +--------------------------+\n     | rep78    foreign   _freq |\n     |--------------------------|\n  1. |     1   Domestic       2 |\n  2. |     2   Domestic       8 |\n  3. |     3   Domestic      27 |\n  4. |     3    Foreign       3 |\n  5. |     4   Domestic       9 |\n     |--------------------------|\n  6. |     4    Foreign       9 |\n  7. |     5   Domestic       2 |\n  8. |     5    Foreign       9 |\n  9. |     .   Domestic       4 |\n 10. |     .    Foreign       1 |\n     +--------------------------+\n\n. restore\n\n. preserve\n\n. contract rep78 foreign, percent(percentage)\n\n. list\n\n     +-------------------------------------+\n     | rep78    foreign   _freq   percen~e |\n     |-------------------------------------|\n  1. |     1   Domestic       2       2.70 |\n  2. |     2   Domestic       8      10.81 |\n  3. |     3   Domestic      27      36.49 |\n  4. |     3    Foreign       3       4.05 |\n  5. |     4   Domestic       9      12.16 |\n     |-------------------------------------|\n  6. |     4    Foreign       9      12.16 |\n  7. |     5   Domestic       2       2.70 |\n  8. |     5    Foreign       9      12.16 |\n  9. |     .   Domestic       4       5.41 |\n 10. |     .    Foreign       1       1.35 |\n     +-------------------------------------+\n\n. restore\n\n."
  },
  {
    "objectID": "chapitre6.html#footnotes",
    "href": "chapitre6.html#footnotes",
    "title": "6  Manipulations des bases de données",
    "section": "",
    "text": "Cela peut être plusieurs bases.↩︎\nm:1 renvoit un message d’erreur. Dans ce sens, la base active doit être period_act et la base using sexe.↩︎\nCela peut être une zône géographique↩︎\nLa question des pondérations sera traitée dans le chapitre suivant↩︎"
  },
  {
    "objectID": "chapitre7.html",
    "href": "chapitre7.html",
    "title": "7  Analyse statistique avec Stata",
    "section": "",
    "text": "[Début maj 30 Aout 2023]"
  },
  {
    "objectID": "chapitre1.html#petit-historique-de-stata",
    "href": "chapitre1.html#petit-historique-de-stata",
    "title": "1  Présentation de Stata",
    "section": "1.1 Petit historique de Stata",
    "text": "1.1 Petit historique de Stata\nL’entreprise Stata Corp Lp a été fondée par William Gould. Il est toujours à la tête de l’entreprise.\n\nPremière version (sous MS Dos) en janvier 1985.\n\nPremière version Windows en 1995 [Stata 4].\n\nLa version la plus récente est la 18 [avril 2023].\nLe rythme de changement de version est de 2 ans. Attention tout de même, il s’agit plutôt de grosses mises à jour, dont l’acquisition systématique est dispensable.\n\n\n\n\n\n\n\nVersions 18 et 17\n\n\n\nVersion 18\n\nUne autosave des programmes (enfin)\nNouveau format .dtas pour enregistrer une liste de frames générées dans un programme.\nGraphiques:\n\nNouvelle palette qualitative et nouveau thème par défaut (enfin). Vous trouverez une courte présentation et quelques visuels ici [[Lien][https://mthevenin.github.io/stata_fr/articles/index/posts/palette_style/palette_style.html]]\nUne nouvelle option colorvar (cf fill, color dans R ou python) qui permet d’empiler automatiquement ou presque plusieurs objets graphiques (autrefois un objet par valeur dans une expression conditionnelle.\n\nNon testé: une commande dtable pour générer et exporter des tableaux de statistiques descriptives.\n\nOn peut consulter la liste des mises à jour sur le site officiel: [Lien]\nVersion 17\nUne rapide présentation a été faite il y a plus d’un an [Lien].\nEn résumé pour la version 17:\n\nAmélioration de la vitesse d’exécution (je confirme)\nSuite collect pour générer des outputs des commandes statistiques et exportables dans plusieurs formats (.doc, .xlsx, .tex, .html, .md). Rapidement testé pour des régressions, c’est plutôt pas mal même si, comme d’habitude avec Stata qui se raccroche aux branche, cela peut vite tourner à l’usine à gaz [rapide présentation]\n\n\n\nMise à jour d’une version\nRégulièrement Stata corrige des bugs ou autres erreurs. On peut obtenir la liste des mises à jour en tapant dans la fenêtre de commande update query.\n\nUpdate status\n    Last check for updates:  30 Aug 2023\n    New update available:    13 Jul 2023  (what's new)\n    Current update level:    15 May 2023  (what's new)\n\n\nPossible actions\n\n    Install available updates             (or type -update all-)\n\n1.1.1 A l’Ined\nPour réaliser la mise à jour, vous devrez vous mettre sur votre compte administrateur (adm_nom). Si vous le connaissez pas le nom de votre compte administrateur et/ou le mot de passe, contacter le service informatique."
  },
  {
    "objectID": "chapitre1.html#versions-stata-à-lined",
    "href": "chapitre1.html#versions-stata-à-lined",
    "title": "1  Présentation de Stata",
    "section": "1.2 Versions Stata à l’Ined",
    "text": "1.2 Versions Stata à l’Ined\n\nVersion 18 Window SE est normalement en cours de déploiement. La version 17 Windows SE a été déployée au printemps 2022.\n\nVersion 17 SE sous Linux (serveur margaux).\n\nPetit rappel pour l’Ined pour Sas et Stata: Quel que soit le logiciel choisi sous environnement Windows (SAS v9.4 ou Stata) vous avez accès à une version de l’autre application sous Linux via le serveur Margaux (SAS Studio ou STATA v17 SE).\nVersion SE: Standard Edition\n\nNombre d’observations: 2.14 milliards\nNombre de variables dans les bases: 32 767\nNombre de variables RHS (limite nombre de colonnes des matrices: 10998)\n\nIl existe également des versions dites MP (Multiple Process), dont la plus puissante gère 120000 variables et 20 milliards d’observations)."
  }
]