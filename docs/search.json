[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "N’intéressera peut-être pas les plus aguerri.e.s à Stata…. quoique. On trouve toujours des années plus tard des nouvelles commandes qui facilitent vraiment les choses (sencode, fre, tabm,…., commandes du package gtools), ou une introduction aux frames (Stata16), qui revisitent les appariements de bases.\nLes chapitres sont téléchargeables en format docx.\nMaj de la formation:\n\n28/07/22 : Les variables. Chapitre 5 [todo: faire un topo sur les formats date avant fin 2023]\n07/10/22 : Introduction. Chapitre 1\n07/10/22 : L’environnement. Chapitre 2\n22/02/23 : Le langage Stata. Chapitre 3\n22/02/23 : Les bases de données. Chapitre 4 [introduction aux frame introduites avec la v16]\n05/07/23 : Opérations sur les bases de données. Chapitre 6 [début reprise du chapitre]\n\nProgrammes des chapitres:\n\nChapitre3\nChapitre4\nChapitre5\nChapitre6\n\n\n\n\nSupport réalisé avec Posit-Rstudio - Quarto.\nVersion Stata: 17-SE"
  },
  {
    "objectID": "formation/chapitre6.html#large-à-long",
    "href": "formation/chapitre6.html#large-à-long",
    "title": "Fusion",
    "section": "1.1 large à long",
    "text": "1.1 large à long"
  },
  {
    "objectID": "formation/chapitre6.html#long-à-large",
    "href": "formation/chapitre6.html#long-à-large",
    "title": "Fusion",
    "section": "1.2 long à large",
    "text": "1.2 long à large"
  },
  {
    "objectID": "profile/profile1.html",
    "href": "profile/profile1.html",
    "title": "Principe",
    "section": "",
    "text": "Un fichier profile.do est un programme qui s’éxécute à l’ouverture d’une session Stata. Ce programme comporte uniquement des éléments de configuration, par exemples:\n\nCréation d’un log de session automatique. J’y tiens, un problème n’arrive pas toujours qu’aux autre.\nAffectation d’un répertoire temporaire autre que celui par défaut\nModification de la localisation du répertoire ado plus (il est conseillé mettre sur le lecteur D à l’Ined ou tout autre lecteur que le C:)\nToutes les commandes de paramétrisation préfixées par set: contrôle du défilement de l’output, affichage du nombre de décimales dans les tableaux de régression etc…\nParamètres des graphiques: thèmes, police d’affichage… Je conseille d’utiliser à minima grstyle de Ben Jann.\n\nToutes les commandes sont donc insérées dans un seule programme, il est possible de les activer, de les désactiver ou de les modifier très facilement selon l’usage du moment.\n\n\n1 Création et modification d’un fichier profile.do\nLe fichier profile.do doit être impérativement enregistré dans le répertoire user:\n\n\nWindows: \"C:/Users/nom_user/\"\nLinux (serveur Margaux): \"home/Users/nom_user/\"\n\n\nUne fois le programme enregistré, son effet n’est pris en compte que pour les sessions ouvertes ultérieurement et non sur celles en cours. Le programme est chargé uniquement à l’ouverture d’une session, un message apparait dans l’output:\n\n\n\n\n\nPour faciliter l’ouverture et l’enregistrement du fichier sous windows sans avoir à se promener dans l’explorateur de fichiers, on peut enregistrer la localisation du répertoire user avec une macro de type global, ici appelée user, et l’ouvrir rapidement avec l’invite de commande windows sous Stata (! ou shell).\nAffectation du répertoire user dans une macro:\n\nglobal user \"C:/Users/nom_user/\"\n\nOuverture du fichier profile.do avec l’invite de commande:\n\n! $user/profile.do\n\n\n\n2 Exemples\nLes quelques exemples de configurations qui suivent sont forcément orientés vers mon propre usage.\n\nadoplusRépertoire temporaireLog automatiqueCommandes de type setGraphiquesPython\n\n\nChangement de la localisation du répertoire où sont enregistrées les commandes externes. Il est préférable de les localiser dans un lecteur autre que le lecteur C:\n\nsysdir set PLUS \"D:/D/ado/plus\"\nsysdir set PERSONAL \"D:/D/ado/personal\"\n\n\n\nOn peut créer un répertoire qui fera office de répertoire d’enregistrement par défaut des fichiers, et affecter les opérations d’ouvertures et de sauvegardes dans ce répertoire.\n\n* Après création du répertoire stata_temp\ncd \"D:\\D\\stata_temp\\\"\n\nC’est très optionnel: on peut demander à Stata d’afficher à l’ouverture le contenu de ce répertoire\n\nnoisily display as txt    \"------------------------------------\"\nnoisily display as result \"  Contenu du repertoire stata_temp  \"\nnoisily display as txt    \"------------------------------------\"\nnoisily dir \"D:/D/stata_temp/\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSi on change dans un programme le répertoire d’affectation par défaut avec cd, ce répertoire stata_temp ne sera plus reconnu comme répertoire par défaut.\nPour palier ce problème on peut affecter une macro à la localisation de ce répertoire.\n\nglobal tmp \"D:/D/stata_temp/\"\n\n\ncd \"path/mon_projet\"  \n\nuse base, clear\nkeep if x==1\nsave $tmp/base_x1, replace\n\nCette solution comporte néanmoins des limites lorsque le programme est utilisé par plusieurs personnes.\n\n\nLa plus utile de toutes les configurations décrites ici.\nAu préalable, je conseille de créer un répertoire d’enregistrement pour ces fichiers logs. Je les enregistre dans un sous répertoire de stat_temp appelé tout simplement log.\n\ncapture log close statalog\nlocal cdt = \"`c(current_date)'\"\nlocal cdt: subinstr local cdt \" \" \"-\", all\nlocal cti = \"`c(current_time)'\"\nlocal cti: subinstr local cti \":\" \".\", all\nlocal statalogname \"statalog_`cdt'_`cti'.log\"\n\nlog using \"$user/stata_temp/log/`statalogname'\" , text name(statalog)\n\nPour le chemin d’accès, j’utilise le répertoire user enregistré sous forme d’une macro (voir plus haut).\nDans ce répertoire sont enregistrés tous les log de session depuis le 1er février 2022.\n\n\n\n\n\n\n\n\n\nIl n’est pas nécessaire d’ajouter l’option permanently comme le fichier profile est chargé à chaque ouverture de session.\nEnsemble des commandes préfixées par set: help set\n\n\nExemple 1: nombre de décimales reportées dans l’output d’une régression avec set cformats (coef, se et bornes ci), set sformats (statistique du test) et set pformats (p-value).\nSi on souhaite fixer le nombre de décimale pour l’ensemble des statistiques à 2\n\nset cformats %9.2f   // max longueur =9\nset sformats %9.2f   // max longueur =8\nset pformats %9.2f   // max longueur =5\n\nExemple 2: déblocage du défilement de l’output\n\nset more off\n\n\n\nDe nouveau avec une commande de type set on peut dans son fichier profile.do changer le thème par défaut avec set scheme nom_scheme.\nJ’ai maintenant pour (bonne) habitude d’utiliser grstyle de Ben Jann (présentation dans la formation dédiée aux graphiques: https://mthevenin.github.io/stata_graphiques/formation32.html#grstyle-de-b.jann).\nSelon l’humeur du moment, on peut générer un thème graphique visuellement bien plus qualitatif que les thèmes usines de Stata, avec seulement quelques arguments.\n\ngrstyle init\ngrstyle set imesh\ngrstyle set legend 11, nobox\ngrstyle set color tableau\n\nPenser à installer les packafes grstyle** et colorpalette avant.\n\n\nEmpêcher le bug graphique qui fait planter Stata avec Anaconda/miniconda\nL’utilisation de conda - Anaconda ou miniconda - n’est pas recommandé pour exécuter du code python dans un programme Stata. Pour preuve, sans les quelques lignes de codes qui suiven, l’exécution d’un graphique utilisant matplotlib risque de faire crasher la session Stata. C’est très désagréable. Plutôt que d’insérer ce code dans le programme, il est préférable de le mettre une bonne fois pour toute dans le profile.do si python est utilisé via conda. Mieux vaut vérifier la localisation exacte du répertoire plugins, je ne sais pas si le chemin qui suit vaut pour toutes les installation de miniconda/anaconda.\n\npython:\nimport os\nos.environ['QT_QPA_PLATFORM_PLUGIN_PATH']=\"C:\\\\Users\\\\thevenin_m\\\\Miniconda3\\\\Library\\\\plugins\\\\plugins\"\nend\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa section qui suit met a disposition mon fichier profile.do. Tout est mis en ligne de commentaire, il suffit de retirer la balise * et de modifier les chemins si nécessaire."
  },
  {
    "objectID": "profile/profile2.html",
    "href": "profile/profile2.html",
    "title": "Exemple profile.do",
    "section": "",
    "text": "**************************\n* profile.do Ined        *\n* M.Thevenin Ined-SMS    *\n**************************\n\n/* \n- Copier le programme ou une partie selon les besoins danx un .do\n- Désactiver les zônes de commentaire *\n- Enregistrer le fichier profile.do dans le répertoire unser\n- Seulement ici les paramètres que j'utilise. On peut, bien évidemment, en ajouter d'autres\n*/  \n  \n*****************************\n* ado + et personal dans D: *\n***************************** \n\n/* modifier les chemin si nécessaire */  \n  \n* sysdir set PLUS \"D:/D/ado/plus\"\n* sysdir set PERSONAL \"D:/D/ado/personal\"\n\n****************\n** STATA_TEMP **\n****************\n\n/* Créer un répertoire, pas forcément du même nom que celui ci et modifier les chemin */  \n  \n* cd \"D:\\D\\stata_temp\\\"\n\n*************************************************\n* affichage du contenu du repertoire stata_temp *\n*************************************************\n\n* noisily display as txt    \"------------------------------------\"\n* noisily display as result \"  Contenu du repertoire stata_temp  \"\n* noisily display as txt    \"------------------------------------\"\n* noisily dir \"D:/D/stata_temp/\"\n\n\n**************************************************\n* chargement du répertoire  $tmp dans stata_temp *\n**************************************************\n\n/* attention si plusieurs utilisateurs d'un même programme, le chemin de $tmp risque de ne pas être reconnu */\n\n* global tmp \"D:/D/stata_temp/\"\n\n\n\n\n******************************************\n* Creation automatique d'un fichier .log *\n******************************************\n\n/* changer le chemin à l'avant dernière ligne: log using.... */\n\n* capture log close statalog\n* local cdt = \"`c(current_date)'\"\n* local cdt: subinstr local cdt \" \" \"-\", all\n* local cti = \"`c(current_time)'\"\n* local cti: subinstr local cti \":\" \".\", all\n* local statalogname \"statalog_`cdt'_`cti'.log\"\n\n* noisily display \"Nom du log: `statalogname'\"\n*  log using \"D:/D/stata_temp/log/`statalogname'\" , text name(statalog)\n*  noisily display \"\"\n\n\n*****************\n* R source path *\n*****************\n\n* global Rterm_path `\"C:\\Program Files\\R\\R-4.1.2\\bin\\R.exe\"'\n\n* global Rterm_options `\"--slave --vanilla --args  \"`tf1'\" \"`tf2'\" \"'\n\n\n***************************************************\n* supprimer le blocage du défilement  de l'output *\n***************************************************\n\n* set more off\n\n*******************************\n* output regression           *\n*******************************\n\n/* nombre de decimales =3 */\n\n* set cformat %9.3f\n\n/* garder baselevel*/\n\n*set showbaselevels on\n\n*******************************\n*      graphique              *\n*******************************\n\n/* Installer au préalab grstyle et colorpalette */\n\n* grstyle init\n* grstyle set imesh\n* grstyle set legend 11, nobox\n* grstyle set color tableau\n\n\n*******************************\n*      python                 *\n*******************************\n\n/* chargement de l'exécutable */\n\n* capture  set python_exec  \"C:/Users/thevenin_m/AppData/Local/Programs/Python/Python310/python.exe\"\n\n\n****** plugin miniconda\n* python:\n* import os\n* os.environ['QT_QPA_PLATFORM_PLUGIN_PATH']=\"C:\\\\Users\\\\thevenin_m\\\\Miniconda3\\\\Library\\\\plugins\\\\plugins\"\n* end"
  },
  {
    "objectID": "formation/chapitre6.html",
    "href": "formation/chapitre6.html",
    "title": "Opérations sur les bases",
    "section": "",
    "text": "Deux types de fusions:\n\nLa fusion verticale non controlée - empilement - (append)\nla fusion horizontale contrôlée - appariement - (merge).\n\n\n\n\n\nConsiste simplement à ajouter des observations entre plusieurs bases, avec ou non un même jeu de variables.\n\n\n\n\n\n\nOn va générer les deux bases de données avec la commande input (non traité dans cette formation: help input).\n\nclear \ninput str6 id v1 v2\n  \"A\" 8 2 \n  \"B\" 1 2 \n  \"C\" 2 4\nend\n\nlist\n\nsave base1, replace\n\n\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n     +--------------+\nfile base1.dta saved\n\n\n\nclear \ninput str20 id v1 v2 v3\n  \"D\" 2 5 10\n  \"E\" 12 1 8 \nend\nlist\n\nsave base2, replace\n\n\n\n     +-------------------+\n     | id   v1   v2   v3 |\n     |-------------------|\n  1. |  D    2    5   10 |\n  2. |  E   12    1    8 |\n     +-------------------+\nfile base2.dta saved\n\n\nLa syntaxe de la commande append consiste à ajouter une ou plusieurs bases à la base active avec l’argument using.\n\nappend using base1\nsort id\nlist\n\n\n     +-------------------+\n     | id   v1   v2   v3 |\n     |-------------------|\n  1. |  A    8    2    . |\n  2. |  B    1    2    . |\n  3. |  C    2    4    . |\n  4. |  D    2    5   10 |\n  5. |  E   12    1    8 |\n     +-------------------+\n\n\nOn peut sélectionner les variables de la base qui sera empilée à la base active avec l’option keep.\nDans l’exemple, si la base active est base1, on peut ne pas vouloir ajouter la variable v3 seulement renseignée pour les observations de base2.\n\nuse base1, clear\nappend using base2, keep(id v1 v2)\nlist \n\n(variable id was str6, now str20 to accommodate using data's values)\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n  4. |  D    2    5 |\n  5. |  E   12    1 |\n     +--------------+\n\n\nSi les informations précédentes étaient ventilées dans trois bases, une par variable v, et avec le même niveau d’observation (A,B,C,D,E dans les 3 bases), l’utilisation de append conduirait à une structure empilée non souhaitable avec une réplication des id.\nPour obtenir la base finale proprement appariée, il convient de faire une fusion horizontale contrôlée par une une clé d’identification.\n\n\n\nStata demande que les bases soient soit triées (sort) sur la clé d’appariement en amont de l’opération. Sinon un message d’erreur sera renvoyé.\n:::\n\nLa base active (ouverte) est appelée base master\nLa base qui sera appariée à la base ouverte est appelée base using 1\n\nSyntaxe minimale 1 avec préfixe:\nmerge [1:1] [1:m] [m:1] id_variables(s) using nom_base\n\nIci on peut apparier plus de deux bases.\nOn ne dispose pas de sécurité, si les niveau d’identification sont différents.\n\n\n\nPartons des informations suivantes: - Base1 comprend la variable d’identification id (observations A,B,C) et de deux variables numériques v1 et v3 - Base2 comprend la même variable d’identification id (observations B,C,D) et de la variable numérique v3\n Le niveau d’identification est identique dans les deux bases. Il s’agit donc d’un merge 1:1 [one to one]\nOn va de nouveau générer les bases avec input.\n\nclear \ninput str1 id v1 v2 \n\"A\" 8 2 \n\"B\" 1 2\n\"C\" 2 4 \nend\nlist\n\nsort id\nsave base1, replace\n\n\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n     +--------------+\nfile base1.dta saved\n\n\nRappel: bien faire le sort sur la base using\n\nclear\ninput str1 id v3 \n\"B\" 10 \n\"C\" 8\n\"D\" 10 \nend\nlist\n\nsort id\nsave base2, replace \n\n\n\n     +---------+\n     | id   v3 |\n     |---------|\n  1. |  B   10 |\n  2. |  C    8 |\n  3. |  D   10 |\n     +---------+\nfile base2.dta saved\n\n\n\nmerge 1:1 id using base1\n\n\n    Result                      Number of obs\n    -----------------------------------------\n    Not matched                             2\n        from master                         1  (_merge==1)\n        from using                          1  (_merge==2)\n\n    Matched                                 2  (_merge==3)\n    -----------------------------------------\n\n\n\nL’output affiche le résultat de l’appariement à l’aide d’un tableau.\nUne variable, _merge, est générée. Elle permettra de filtrer si nécessaire les observations selon le résultat de l’aapriement. Contrairement à d’autres application, cette opération n’est pas effectuée en amont avec des fonctions où des options spécifiques. Par exemple avec R: left_join, right_join, inner_join. _merge = 1 : observations qui se trouvent seulement dans la base active (master) _merge = 2 : observations qui se trouvent seulement dans la base using (appariée) _merge = 3 : observations communes aux bases master et using.\nLes variables de la base master/active sont positionnées en tête.\n\n\nsort id\nlist\n\n\n     +-------------------------------------+\n     | id   v3   v1   v2            _merge |\n     |-------------------------------------|\n  1. |  A    .    8    2    Using only (2) |\n  2. |  B   10    1    2       Matched (3) |\n  3. |  C    8    2    4       Matched (3) |\n  4. |  D   10    .    .   Master only (1) |\n     +-------------------------------------+\n\n\nSi on souhaite seulement conserver les observations communes aux deux bases (_merge=3):\n\nkeep if _merge==3\nlist\n\n(2 observations deleted)\n\n     +---------------------------------+\n     | id   v3   v1   v2        _merge |\n     |---------------------------------|\n  1. |  B   10    1    2   Matched (3) |\n  2. |  C    8    2    4   Matched (3) |\n     +---------------------------------+\n\n\n\n\n\n\n\n\nVariable _merge et appariement successif\n\n\n\nPensez à supprimer la variable _merge si plusieurs opérérations d’appariement sont effectués. La commande ne prévoit pas d’écraser la variable du merge précédent.\n\n\nSituation avec plus d’une base à apparier\nOn ne peux pas utiliser la syntaxe avec préfixe (ici merge 1:1).\nOn va ajouter une nouvelle base qui sera appariée avec les deux premières, qui seront donc les deux bases de type using.\n\nclear\ninput str1 id str3  v4 \n\"A\" \"Non\" \n\"B\" \"Oui\" \n\"C\" \"Oui\" \nend\n\nlist \n\nsort id\n\n\n\n     +----------+\n     | id    v4 |\n     |----------|\n  1. |  A   Non |\n  2. |  B   Oui |\n  3. |  C   Oui |\n     +----------+\n\n\n\nmerge id using base1 base2\n\norder id v1 v2 v3 v4 _merge1 _merge2 _merge \n\nlist\n\n(you are using old merge syntax; see [D] merge for new syntax)\n\n     +------------------------------------------------------+\n     | id   v1   v2   v3    v4   _merge1   _merge2   _merge |\n     |------------------------------------------------------|\n  1. |  A    8    2    .   Non         1         0        3 |\n  2. |  B    1    2   10   Oui         1         1        3 |\n  3. |  C    2    4    8   Oui         1         1        3 |\n  4. |  D    .    .   10               0         1        2 |\n     +------------------------------------------------------+\n\n\nOn obtient maintenant 3 variables _merge:\n\n_merge1. Donne le résultat de l’appariement entre la nouvelle base et base1: 0 si seulement dans une seule des deux bases (D), 1 si dans les deux bases (A,B,C).\n_merge2. Donne le résultat de l’appariement entre la nouvelle base et base2: 0 si seulement dans une seule des deux bases (A,D), 1 si dans les deux bases (B,C).\n_merge. Résume rapidement le matching entre les bases: on retrouve au moins une fois les observations (A,B,C) dans l’un des deux appariement (_merge=3), on trouve une observation (D) qui ne se trouve que dans une base using (_D_merge=2).\n\nSi l’on souhaite conserver les observations communes aux trois bases, on peut sommer les valeurs de _merge1 et _merge2 et conserver les observations dont la valeurs de cette somme est égale au nombre d’appariements; ou faire une sélection des observations avec un filtre conditionnel, ici:\n\nkeep if _merge1==1 & _merge2==1\nlist\n\ndrop _merge*\n\n(2 observations deleted)\n\n     +------------------------------------------------------+\n     | id   v1   v2   v3    v4   _merge1   _merge2   _merge |\n     |------------------------------------------------------|\n  1. |  B    1    2   10   Oui         1         1        3 |\n  2. |  C    2    4    8   Oui         1         1        3 |\n     +------------------------------------------------------+\n\n\n\n\n\n\n\n\nCommande join du package ftools\n\n\n\n[A tester]\n\nDocumentation.\nPermet de gagner 70% de durée d’exécution lorsque la volumétrie dépasse 100000 observations\nGère en amont le tri des bases appariée.\n\n\n\n\n\n\nUn merge de type 1:1 n’est pas possible. Dans l’exemple qui suit la base period_act liste pour deux personnes le statut d’activité observé pour plusieurs périodes soit des observations multiples pour chaque individus, et la base sexe donne une caractéristique unique pour chaque individu. Selon le statut des bases appariée (maste ou using), l’appariement est de type 1:m ou m:1.\n\nSi la base active est à observations multiple sur la clé d’identification: m:1\nSi la base active est à observation unique sur la clé d’identification: 1:m\n\n\n\n\n\n\nOn va de nouveau générer les données avec input\n\nclear \ninput id périodes str8 Activité\n1 1 \"Emploi\"\n1 2 \"Emploi\"\n1 3 \"Chômage\"\n2 1 \"Chômage\" \n2 2 \"Chômage\"\n2 3 \"Emploi\"\n2 4 \"Chômage\" \nend \nlist \nsort id \nsave \"period_act\", replace\n\n\n\n     +--------------------------+\n     | id   périodes   Activité |\n     |--------------------------|\n  1. |  1          1     Emploi |\n  2. |  1          2     Emploi |\n  3. |  1          3    Chômage |\n  4. |  2          1    Chômage |\n  5. |  2          2    Chômage |\n     |--------------------------|\n  6. |  2          3     Emploi |\n  7. |  2          4    Chômage |\n     +--------------------------+\nfile period_act.dta saved\n\n\n\nclear\ninput id str6 sexe \n1 \"Homme\"  \n2 \"Femme\"  \nend \nlist\nsort id \nsave \"sexe\", replace\n\n\n\n     +------------+\n     | id    sexe |\n     |------------|\n  1. |  1   Homme |\n  2. |  2   Femme |\n     +------------+\nfile sexe.dta saved\n\n\nSi on faisait un merge 1:1, Stata renverrai le message d’erreur suivant:\nmerge 1:1 id using activités\n\nvariable id does not uniquely identify observations in the using data\nr(459);\nIci la base active est la base sex. Le prefixe qui doit être utilisé est donc 1:m 2\n\nmerge 1:m id using period_act\nsort id période\nlist \n\n\n    Result                      Number of obs\n    -----------------------------------------\n    Not matched                             0\n    Matched                                 7  (_merge==3)\n    -----------------------------------------\n\n     +------------------------------------------------+\n     | id    sexe   périodes   Activité        _merge |\n     |------------------------------------------------|\n  1. |  1   Homme          1     Emploi   Matched (3) |\n  2. |  1   Homme          2     Emploi   Matched (3) |\n  3. |  1   Homme          3    Chômage   Matched (3) |\n  4. |  2   Femme          1    Chômage   Matched (3) |\n  5. |  2   Femme          2    Chômage   Matched (3) |\n     |------------------------------------------------|\n  6. |  2   Femme          3     Emploi   Matched (3) |\n  7. |  2   Femme          4    Chômage   Matched (3) |\n     +------------------------------------------------+\n\n\n\n\n\n\n\n\nTip\n\n\n\nLe tri de la base est régulièrement modifié après ce type d’appariement. Penser donc à retrier les données proprement, surtout quand il s’agit comme ici d’informations biographiques (sort id périodes)\n\n\nDe nouveau les préfixes sont optionnels, et permettent seulement de contrôler l’appariement. On peut sans soucis fusionner des informations contextuelles avec des informations multiples avec seulement merge.\n\nuse sexe, clear\nmerge id using period_act\nsort id périodes\nlist\n\n(you are using old merge syntax; see [D] merge for new syntax)\nvariable id does not uniquely identify observations in period_act.dta\n\n     +-------------------------------------------+\n     | id    sexe   périodes   Activité   _merge |\n     |-------------------------------------------|\n  1. |  1   Homme          1     Emploi        3 |\n  2. |  1   Homme          2     Emploi        3 |\n  3. |  1   Homme          3    Chômage        3 |\n  4. |  2   Femme          1    Chômage        3 |\n  5. |  2   Femme          2    Chômage        3 |\n     |-------------------------------------------|\n  6. |  2   Femme          3     Emploi        3 |\n  7. |  2   Femme          4    Chômage        3 |\n     +-------------------------------------------+\n\n\n\n\n\nPour les personnes qui n’ont jamais manipulé des frames (introduction Stata 16), se reporter à l’aide Stata (help frame) ou à ce court article.\nL’utilisation des frames présentent plusieurs avantages:\n\nIl n’est pas nécessaire de trier les bases concernées par l’appariement\nOn peut sélectionner avec la commande frget la ou les variables qui seront récupérées dans la base master. On apparie donc pas des bases en tant que telles, on récupère de l’information de frames liées\n\nAu niveau des désavantages:\n\nSi on ne travaille pas exclusivement sous frames, on devra transformer les bases en frame (voir exemple)\nAbsence de variable de type _merge, qui permet de contrôler le résultat de l’appariement.\nles prefixes sont 1:1 et m:1. Cela signifie dans le second cas que la frame active lors de l’opération de liaison doit toujours être celle dont la clé d’identification est de type multiple (niveau individuel).\nPeut-être le plus embêtant est l’absence d’appariement pour les informations correspondant à merge=2 (informations seulement présentes dans la base using). Le dernier exemple illustre ce point.\n\nOn reprend l’exemple précédent, en transformant dans un premier temps les deux bases en frames.\n\nframe reset\n\nframe create period_act\nframe period_act: use period_act\nframe create sexe\nframe sexe: use sexe\n\nframe dir\n\n  default     0 x 0\n  period_act  7 x 3; period_act.dta\n  sexe        2 x 2; sexe.dta\n\n\nOn doit se positionner sur la frame period_act (type m)\n\nframe change period_act\n\nPour lier les frames on utilise la commande frlink.\nSyntaxe\nfrlink 1:1/m:1 id_variable(s), frame(nom_frame) gen(variable_lien)\nIci on fait un appariement de type m:1, la clé d’identification est de nouveau id. On lie la frame active à la frame sexe et la variable de liaison (ici un alias de la variable id) est appelée link.\n\nfrlink m:1 id, frame(sexe) gen(link)\n\n(all observations in frame period_act matched)\n\n\nPour importer la variable sexe dans la frame period_act, on utilise la commande frget, en précisant la ou les variable que l’on souhaite récupérer, ainsi que la variable de liaison (une même frame peut avoir plusieurs liaisons. Voir plus loin).\n\nfrget sexe , from(link)\n\nframe period_act: order link, last\nlist\n\n(1 variable copied from linked frame)\n\n     +-----------------------------------------+\n     | id   périodes   Activité    sexe   link |\n     |-----------------------------------------|\n  1. |  1          1     Emploi   Homme      1 |\n  2. |  1          2     Emploi   Homme      1 |\n  3. |  1          3    Chômage   Homme      1 |\n  4. |  2          1    Chômage   Femme      2 |\n  5. |  2          2    Chômage   Femme      2 |\n     |-----------------------------------------|\n  6. |  2          3     Emploi   Femme      2 |\n  7. |  2          4    Chômage   Femme      2 |\n     +-----------------------------------------+\n\n\n\n\n\n\n\n\nLiaison des frames en présence d’information incomplète\n\n\n\nLa liaison de frames peut être problématique en présence d’informations incomplètes. Pour faire simple la liaison des frames permet de faire des appariements de type merge=1 et merge=3 (présence dans master seulement / présence dans master et using) mais ne permet pas de récupérer des informations présentes seulement dans la base using).\nPour illustrer cela on va génére une nouvelle framme, de type individu période, avec une variable additionnelle tvc.\n\nPour id= 1, on a pas d’information dans la frame period_act pour période=4\nPour id= 2, on a pas d’information dans la frame tvc pour les périodes 3 et 4.\n\nCréation de la nouvelle frame (voir le .do, la compilation pour générer ce support complexifie un peu l’opération):\n\nframe create tvc\nframe change tvc\n\n\nclear\ninput id périodes tvc \n1 1 0   \n1 2 0   \n1 3 1  \n1 4 0  \n2 1 1  \n2 2 0 \nend\n\nlist \n\nsave tvc, replace\nframe tvc: use tvc\n\n\n\n     +---------------------+\n     | id   périodes   tvc |\n     |---------------------|\n  1. |  1          1     0 |\n  2. |  1          2     0 |\n  3. |  1          3     1 |\n  4. |  1          4     0 |\n  5. |  2          1     1 |\n     |---------------------|\n  6. |  2          2     0 |\n     +---------------------+\nfile tvc.dta saved\n\n\nLiaison des frames et récupération de la variable tvc dans period_act\n\nframe change period_act\nfrlink 1:1 id périodes, frame(tvc) gen(link2)\n\nfrget tvc, from(link2)\n\nlist\n\n(2 observations in frame period_act unmatched)\n(2 missing values generated)\n(1 variable copied from linked frame)\n\n     +-------------------------------------------------------+\n     | id   périodes   Activité    sexe   link   link2   tvc |\n     |-------------------------------------------------------|\n  1. |  1          1     Emploi   Homme      1       1     0 |\n  2. |  1          2     Emploi   Homme      1       2     0 |\n  3. |  1          3    Chômage   Homme      1       3     1 |\n  4. |  2          1    Chômage   Femme      2       5     1 |\n  5. |  2          2    Chômage   Femme      2       6     0 |\n     |-------------------------------------------------------|\n  6. |  2          3     Emploi   Femme      2       .     . |\n  7. |  2          4    Chômage   Femme      2       .     . |\n     +-------------------------------------------------------+\n\n\nOn voit bien que la valeur de tvc pour id=1 et périodes=4 n’a pas été importée (_merge=2 dans un appariement classique). En revanche, pour id=2, l’incomplétude de l’information dans la base tvc pour les périodes 3 et 4 est bien visible.\nAvec un merge classique (on suppose que period_act n’a pas été appariée à sexe):\n\nuse tvc, clear\nsort id périodes\nsave tvc, replace\nuse period_act, clear\nsort id périodes\nmerge 1:1 id périodes using tvc\nsort id périodes\nlist\n\nfile tvc.dta saved\n\n    Result                      Number of obs\n    -----------------------------------------\n    Not matched                             3\n        from master                         2  (_merge==1)\n        from using                          1  (_merge==2)\n\n    Matched                                 5  (_merge==3)\n    -----------------------------------------\n\n     +--------------------------------------------------+\n     | id   périodes   Activité   tvc            _merge |\n     |--------------------------------------------------|\n  1. |  1          1     Emploi     0       Matched (3) |\n  2. |  1          2     Emploi     0       Matched (3) |\n  3. |  1          3    Chômage     1       Matched (3) |\n  4. |  1          4                0    Using only (2) |\n  5. |  2          1    Chômage     1       Matched (3) |\n     |--------------------------------------------------|\n  6. |  2          2    Chômage     0       Matched (3) |\n  7. |  2          3     Emploi     .   Master only (1) |\n  8. |  2          4    Chômage     .   Master only (1) |\n     +--------------------------------------------------+\n\n\nOn a bien ici l’ajout de l’information correspondant à _merge=2 (Using only)\n\n\n[05-07-2023]"
  },
  {
    "objectID": "formation/chapitre6.html#append",
    "href": "formation/chapitre6.html#append",
    "title": "Opérations sur les bases",
    "section": "",
    "text": "Consiste simplement à ajouter des observations entre plusieurs bases, avec ou non un même jeu de variables.\n\n\n\n\n\n\nOn va générer les deux bases de données avec la commande input (non traité dans cette formation: help input).\n\nclear \ninput str6 id v1 v2\n  \"A\" 8 2 \n  \"B\" 1 2 \n  \"C\" 2 4\nend\n\nlist\n\nsave base1, replace\n\n\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n     +--------------+\nfile base1.dta saved\n\n\n\nclear \ninput str20 id v1 v2 v3\n  \"D\" 2 5 10\n  \"E\" 12 1 8 \nend\nlist\n\nsave base2, replace\n\n\n\n     +-------------------+\n     | id   v1   v2   v3 |\n     |-------------------|\n  1. |  D    2    5   10 |\n  2. |  E   12    1    8 |\n     +-------------------+\nfile base2.dta saved\n\n\nLa syntaxe de la commande append consiste à ajouter une ou plusieurs bases à la base active avec l’argument using.\n\nappend using base1\nsort id\nlist\n\n\n     +-------------------+\n     | id   v1   v2   v3 |\n     |-------------------|\n  1. |  A    8    2    . |\n  2. |  B    1    2    . |\n  3. |  C    2    4    . |\n  4. |  D    2    5   10 |\n  5. |  E   12    1    8 |\n     +-------------------+\n\n\nOn peut sélectionner les variables de la base qui sera empilée à la base active avec l’option keep.\nDans l’exemple, si la base active est base1, on peut ne pas vouloir ajouter la variable v3 seulement renseignée pour les observations de base2.\n\nuse base1, clear\nappend using base2, keep(id v1 v2)\nlist \n\n(variable id was str6, now str20 to accommodate using data's values)\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n  4. |  D    2    5 |\n  5. |  E   12    1 |\n     +--------------+\n\n\nSi les informations précédentes étaient ventilées dans trois bases, une par variable v, et avec le même niveau d’observation (A,B,C,D,E dans les 3 bases), l’utilisation de append conduirait à une structure empilée non souhaitable avec une réplication des id.\nPour obtenir la base finale proprement appariée, il convient de faire une fusion horizontale contrôlée par une une clé d’identification."
  },
  {
    "objectID": "formation/chapitre6.html#merge",
    "href": "formation/chapitre6.html#merge",
    "title": "Opérations sur les bases",
    "section": "",
    "text": "Stata demande que les bases soient soit triées (sort) sur la clé d’appariement en amont de l’opération. Sinon un message d’erreur sera renvoyé.\n:::\n\nLa base active (ouverte) est appelée base master\nLa base qui sera appariée à la base ouverte est appelée base using 1\n\nSyntaxe minimale 1 avec préfixe:\nmerge [1:1] [1:m] [m:1] id_variables(s) using nom_base\n\nIci on peut apparier plus de deux bases.\nOn ne dispose pas de sécurité, si les niveau d’identification sont différents.\n\n\n\nPartons des informations suivantes: - Base1 comprend la variable d’identification id (observations A,B,C) et de deux variables numériques v1 et v3 - Base2 comprend la même variable d’identification id (observations B,C,D) et de la variable numérique v3\n Le niveau d’identification est identique dans les deux bases. Il s’agit donc d’un merge 1:1 [one to one]\nOn va de nouveau générer les bases avec input.\n\nclear \ninput str1 id v1 v2 \n\"A\" 8 2 \n\"B\" 1 2\n\"C\" 2 4 \nend\nlist\n\nsort id\nsave base1, replace\n\n\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n     +--------------+\nfile base1.dta saved\n\n\nRappel: bien faire le sort sur la base using\n\nclear\ninput str1 id v3 \n\"B\" 10 \n\"C\" 8\n\"D\" 10 \nend\nlist\n\nsort id\nsave base2, replace \n\n\n\n     +---------+\n     | id   v3 |\n     |---------|\n  1. |  B   10 |\n  2. |  C    8 |\n  3. |  D   10 |\n     +---------+\nfile base2.dta saved\n\n\n\nmerge 1:1 id using base1\n\n\n    Result                      Number of obs\n    -----------------------------------------\n    Not matched                             2\n        from master                         1  (_merge==1)\n        from using                          1  (_merge==2)\n\n    Matched                                 2  (_merge==3)\n    -----------------------------------------\n\n\n\nL’output affiche le résultat de l’appariement à l’aide d’un tableau.\nUne variable, _merge, est générée. Elle permettra de filtrer si nécessaire les observations selon le résultat de l’aapriement. Contrairement à d’autres application, cette opération n’est pas effectuée en amont avec des fonctions où des options spécifiques. Par exemple avec R: left_join, right_join, inner_join. _merge = 1 : observations qui se trouvent seulement dans la base active (master) _merge = 2 : observations qui se trouvent seulement dans la base using (appariée) _merge = 3 : observations communes aux bases master et using.\nLes variables de la base master/active sont positionnées en tête.\n\n\nsort id\nlist\n\n\n     +-------------------------------------+\n     | id   v3   v1   v2            _merge |\n     |-------------------------------------|\n  1. |  A    .    8    2    Using only (2) |\n  2. |  B   10    1    2       Matched (3) |\n  3. |  C    8    2    4       Matched (3) |\n  4. |  D   10    .    .   Master only (1) |\n     +-------------------------------------+\n\n\nSi on souhaite seulement conserver les observations communes aux deux bases (_merge=3):\n\nkeep if _merge==3\nlist\n\n(2 observations deleted)\n\n     +---------------------------------+\n     | id   v3   v1   v2        _merge |\n     |---------------------------------|\n  1. |  B   10    1    2   Matched (3) |\n  2. |  C    8    2    4   Matched (3) |\n     +---------------------------------+\n\n\n\n\n\n\n\n\nVariable _merge et appariement successif\n\n\n\nPensez à supprimer la variable _merge si plusieurs opérérations d’appariement sont effectués. La commande ne prévoit pas d’écraser la variable du merge précédent.\n\n\nSituation avec plus d’une base à apparier\nOn ne peux pas utiliser la syntaxe avec préfixe (ici merge 1:1).\nOn va ajouter une nouvelle base qui sera appariée avec les deux premières, qui seront donc les deux bases de type using.\n\nclear\ninput str1 id str3  v4 \n\"A\" \"Non\" \n\"B\" \"Oui\" \n\"C\" \"Oui\" \nend\n\nlist \n\nsort id\n\n\n\n     +----------+\n     | id    v4 |\n     |----------|\n  1. |  A   Non |\n  2. |  B   Oui |\n  3. |  C   Oui |\n     +----------+\n\n\n\nmerge id using base1 base2\n\norder id v1 v2 v3 v4 _merge1 _merge2 _merge \n\nlist\n\n(you are using old merge syntax; see [D] merge for new syntax)\n\n     +------------------------------------------------------+\n     | id   v1   v2   v3    v4   _merge1   _merge2   _merge |\n     |------------------------------------------------------|\n  1. |  A    8    2    .   Non         1         0        3 |\n  2. |  B    1    2   10   Oui         1         1        3 |\n  3. |  C    2    4    8   Oui         1         1        3 |\n  4. |  D    .    .   10               0         1        2 |\n     +------------------------------------------------------+\n\n\nOn obtient maintenant 3 variables _merge:\n\n_merge1. Donne le résultat de l’appariement entre la nouvelle base et base1: 0 si seulement dans une seule des deux bases (D), 1 si dans les deux bases (A,B,C).\n_merge2. Donne le résultat de l’appariement entre la nouvelle base et base2: 0 si seulement dans une seule des deux bases (A,D), 1 si dans les deux bases (B,C).\n_merge. Résume rapidement le matching entre les bases: on retrouve au moins une fois les observations (A,B,C) dans l’un des deux appariement (_merge=3), on trouve une observation (D) qui ne se trouve que dans une base using (_D_merge=2).\n\nSi l’on souhaite conserver les observations communes aux trois bases, on peut sommer les valeurs de _merge1 et _merge2 et conserver les observations dont la valeurs de cette somme est égale au nombre d’appariements; ou faire une sélection des observations avec un filtre conditionnel, ici:\n\nkeep if _merge1==1 & _merge2==1\nlist\n\ndrop _merge*\n\n(2 observations deleted)\n\n     +------------------------------------------------------+\n     | id   v1   v2   v3    v4   _merge1   _merge2   _merge |\n     |------------------------------------------------------|\n  1. |  B    1    2   10   Oui         1         1        3 |\n  2. |  C    2    4    8   Oui         1         1        3 |\n     +------------------------------------------------------+\n\n\n\n\n\n\n\n\nCommande join du package ftools\n\n\n\n[A tester]\n\nDocumentation.\nPermet de gagner 70% de durée d’exécution lorsque la volumétrie dépasse 100000 observations\nGère en amont le tri des bases appariée.\n\n\n\n\n\n\nUn merge de type 1:1 n’est pas possible. Dans l’exemple qui suit la base period_act liste pour deux personnes le statut d’activité observé pour plusieurs périodes soit des observations multiples pour chaque individus, et la base sexe donne une caractéristique unique pour chaque individu. Selon le statut des bases appariée (maste ou using), l’appariement est de type 1:m ou m:1.\n\nSi la base active est à observations multiple sur la clé d’identification: m:1\nSi la base active est à observation unique sur la clé d’identification: 1:m\n\n\n\n\n\n\nOn va de nouveau générer les données avec input\n\nclear \ninput id périodes str8 Activité\n1 1 \"Emploi\"\n1 2 \"Emploi\"\n1 3 \"Chômage\"\n2 1 \"Chômage\" \n2 2 \"Chômage\"\n2 3 \"Emploi\"\n2 4 \"Chômage\" \nend \nlist \nsort id \nsave \"period_act\", replace\n\n\n\n     +--------------------------+\n     | id   périodes   Activité |\n     |--------------------------|\n  1. |  1          1     Emploi |\n  2. |  1          2     Emploi |\n  3. |  1          3    Chômage |\n  4. |  2          1    Chômage |\n  5. |  2          2    Chômage |\n     |--------------------------|\n  6. |  2          3     Emploi |\n  7. |  2          4    Chômage |\n     +--------------------------+\nfile period_act.dta saved\n\n\n\nclear\ninput id str6 sexe \n1 \"Homme\"  \n2 \"Femme\"  \nend \nlist\nsort id \nsave \"sexe\", replace\n\n\n\n     +------------+\n     | id    sexe |\n     |------------|\n  1. |  1   Homme |\n  2. |  2   Femme |\n     +------------+\nfile sexe.dta saved\n\n\nSi on faisait un merge 1:1, Stata renverrai le message d’erreur suivant:\nmerge 1:1 id using activités\n\nvariable id does not uniquely identify observations in the using data\nr(459);\nIci la base active est la base sex. Le prefixe qui doit être utilisé est donc 1:m 2\n\nmerge 1:m id using period_act\nsort id période\nlist \n\n\n    Result                      Number of obs\n    -----------------------------------------\n    Not matched                             0\n    Matched                                 7  (_merge==3)\n    -----------------------------------------\n\n     +------------------------------------------------+\n     | id    sexe   périodes   Activité        _merge |\n     |------------------------------------------------|\n  1. |  1   Homme          1     Emploi   Matched (3) |\n  2. |  1   Homme          2     Emploi   Matched (3) |\n  3. |  1   Homme          3    Chômage   Matched (3) |\n  4. |  2   Femme          1    Chômage   Matched (3) |\n  5. |  2   Femme          2    Chômage   Matched (3) |\n     |------------------------------------------------|\n  6. |  2   Femme          3     Emploi   Matched (3) |\n  7. |  2   Femme          4    Chômage   Matched (3) |\n     +------------------------------------------------+\n\n\n\n\n\n\n\n\nTip\n\n\n\nLe tri de la base est régulièrement modifié après ce type d’appariement. Penser donc à retrier les données proprement, surtout quand il s’agit comme ici d’informations biographiques (sort id périodes)\n\n\nDe nouveau les préfixes sont optionnels, et permettent seulement de contrôler l’appariement. On peut sans soucis fusionner des informations contextuelles avec des informations multiples avec seulement merge.\n\nuse sexe, clear\nmerge id using period_act\nsort id périodes\nlist\n\n(you are using old merge syntax; see [D] merge for new syntax)\nvariable id does not uniquely identify observations in period_act.dta\n\n     +-------------------------------------------+\n     | id    sexe   périodes   Activité   _merge |\n     |-------------------------------------------|\n  1. |  1   Homme          1     Emploi        3 |\n  2. |  1   Homme          2     Emploi        3 |\n  3. |  1   Homme          3    Chômage        3 |\n  4. |  2   Femme          1    Chômage        3 |\n  5. |  2   Femme          2    Chômage        3 |\n     |-------------------------------------------|\n  6. |  2   Femme          3     Emploi        3 |\n  7. |  2   Femme          4    Chômage        3 |\n     +-------------------------------------------+\n\n\n\n\n\nPour les personnes qui n’ont jamais manipulé des frames (introduction Stata 16), se reporter à l’aide Stata (help frame) ou à ce court article.\nL’utilisation des frames présentent plusieurs avantages:\n\nIl n’est pas nécessaire de trier les bases concernées par l’appariement\nOn peut sélectionner avec la commande frget la ou les variables qui seront récupérées dans la base master. On apparie donc pas des bases en tant que telles, on récupère de l’information de frames liées\n\nAu niveau des désavantages:\n\nSi on ne travaille pas exclusivement sous frames, on devra transformer les bases en frame (voir exemple)\nAbsence de variable de type _merge, qui permet de contrôler le résultat de l’appariement.\nles prefixes sont 1:1 et m:1. Cela signifie dans le second cas que la frame active lors de l’opération de liaison doit toujours être celle dont la clé d’identification est de type multiple (niveau individuel).\nPeut-être le plus embêtant est l’absence d’appariement pour les informations correspondant à merge=2 (informations seulement présentes dans la base using). Le dernier exemple illustre ce point.\n\nOn reprend l’exemple précédent, en transformant dans un premier temps les deux bases en frames.\n\nframe reset\n\nframe create period_act\nframe period_act: use period_act\nframe create sexe\nframe sexe: use sexe\n\nframe dir\n\n  default     0 x 0\n  period_act  7 x 3; period_act.dta\n  sexe        2 x 2; sexe.dta\n\n\nOn doit se positionner sur la frame period_act (type m)\n\nframe change period_act\n\nPour lier les frames on utilise la commande frlink.\nSyntaxe\nfrlink 1:1/m:1 id_variable(s), frame(nom_frame) gen(variable_lien)\nIci on fait un appariement de type m:1, la clé d’identification est de nouveau id. On lie la frame active à la frame sexe et la variable de liaison (ici un alias de la variable id) est appelée link.\n\nfrlink m:1 id, frame(sexe) gen(link)\n\n(all observations in frame period_act matched)\n\n\nPour importer la variable sexe dans la frame period_act, on utilise la commande frget, en précisant la ou les variable que l’on souhaite récupérer, ainsi que la variable de liaison (une même frame peut avoir plusieurs liaisons. Voir plus loin).\n\nfrget sexe , from(link)\n\nframe period_act: order link, last\nlist\n\n(1 variable copied from linked frame)\n\n     +-----------------------------------------+\n     | id   périodes   Activité    sexe   link |\n     |-----------------------------------------|\n  1. |  1          1     Emploi   Homme      1 |\n  2. |  1          2     Emploi   Homme      1 |\n  3. |  1          3    Chômage   Homme      1 |\n  4. |  2          1    Chômage   Femme      2 |\n  5. |  2          2    Chômage   Femme      2 |\n     |-----------------------------------------|\n  6. |  2          3     Emploi   Femme      2 |\n  7. |  2          4    Chômage   Femme      2 |\n     +-----------------------------------------+\n\n\n\n\n\n\n\n\nLiaison des frames en présence d’information incomplète\n\n\n\nLa liaison de frames peut être problématique en présence d’informations incomplètes. Pour faire simple la liaison des frames permet de faire des appariements de type merge=1 et merge=3 (présence dans master seulement / présence dans master et using) mais ne permet pas de récupérer des informations présentes seulement dans la base using).\nPour illustrer cela on va génére une nouvelle framme, de type individu période, avec une variable additionnelle tvc.\n\nPour id= 1, on a pas d’information dans la frame period_act pour période=4\nPour id= 2, on a pas d’information dans la frame tvc pour les périodes 3 et 4.\n\nCréation de la nouvelle frame (voir le .do, la compilation pour générer ce support complexifie un peu l’opération):\n\nframe create tvc\nframe change tvc\n\n\nclear\ninput id périodes tvc \n1 1 0   \n1 2 0   \n1 3 1  \n1 4 0  \n2 1 1  \n2 2 0 \nend\n\nlist \n\nsave tvc, replace\nframe tvc: use tvc\n\n\n\n     +---------------------+\n     | id   périodes   tvc |\n     |---------------------|\n  1. |  1          1     0 |\n  2. |  1          2     0 |\n  3. |  1          3     1 |\n  4. |  1          4     0 |\n  5. |  2          1     1 |\n     |---------------------|\n  6. |  2          2     0 |\n     +---------------------+\nfile tvc.dta saved\n\n\nLiaison des frames et récupération de la variable tvc dans period_act\n\nframe change period_act\nfrlink 1:1 id périodes, frame(tvc) gen(link2)\n\nfrget tvc, from(link2)\n\nlist\n\n(2 observations in frame period_act unmatched)\n(2 missing values generated)\n(1 variable copied from linked frame)\n\n     +-------------------------------------------------------+\n     | id   périodes   Activité    sexe   link   link2   tvc |\n     |-------------------------------------------------------|\n  1. |  1          1     Emploi   Homme      1       1     0 |\n  2. |  1          2     Emploi   Homme      1       2     0 |\n  3. |  1          3    Chômage   Homme      1       3     1 |\n  4. |  2          1    Chômage   Femme      2       5     1 |\n  5. |  2          2    Chômage   Femme      2       6     0 |\n     |-------------------------------------------------------|\n  6. |  2          3     Emploi   Femme      2       .     . |\n  7. |  2          4    Chômage   Femme      2       .     . |\n     +-------------------------------------------------------+\n\n\nOn voit bien que la valeur de tvc pour id=1 et périodes=4 n’a pas été importée (_merge=2 dans un appariement classique). En revanche, pour id=2, l’incomplétude de l’information dans la base tvc pour les périodes 3 et 4 est bien visible.\nAvec un merge classique (on suppose que period_act n’a pas été appariée à sexe):\n\nuse tvc, clear\nsort id périodes\nsave tvc, replace\nuse period_act, clear\nsort id périodes\nmerge 1:1 id périodes using tvc\nsort id périodes\nlist\n\nfile tvc.dta saved\n\n    Result                      Number of obs\n    -----------------------------------------\n    Not matched                             3\n        from master                         2  (_merge==1)\n        from using                          1  (_merge==2)\n\n    Matched                                 5  (_merge==3)\n    -----------------------------------------\n\n     +--------------------------------------------------+\n     | id   périodes   Activité   tvc            _merge |\n     |--------------------------------------------------|\n  1. |  1          1     Emploi     0       Matched (3) |\n  2. |  1          2     Emploi     0       Matched (3) |\n  3. |  1          3    Chômage     1       Matched (3) |\n  4. |  1          4                0    Using only (2) |\n  5. |  2          1    Chômage     1       Matched (3) |\n     |--------------------------------------------------|\n  6. |  2          2    Chômage     0       Matched (3) |\n  7. |  2          3     Emploi     .   Master only (1) |\n  8. |  2          4    Chômage     .   Master only (1) |\n     +--------------------------------------------------+\n\n\nOn a bien ici l’ajout de l’information correspondant à _merge=2 (Using only)\n\n\n[05-07-2023]"
  },
  {
    "objectID": "formation/chapitre6.html#avec-des-frames",
    "href": "formation/chapitre6.html#avec-des-frames",
    "title": "Fusion",
    "section": "0.3 Avec des frames",
    "text": "0.3 Avec des frames"
  },
  {
    "objectID": "formation/chapitre6.html#footnotes",
    "href": "formation/chapitre6.html#footnotes",
    "title": "Opérations sur les bases",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nCela peut être plusieurs bases.↩︎\nm:1 renvoit un message d’erreur. Dans ce sens, la base active doit être period_act et la base using sexe.↩︎"
  },
  {
    "objectID": "formation/chapitre6.html#appariement-avec-ftools",
    "href": "formation/chapitre6.html#appariement-avec-ftools",
    "title": "Fusion",
    "section": "0.3 Appariement avec ftools",
    "text": "0.3 Appariement avec ftools"
  },
  {
    "objectID": "formation/chapitre6.html#appariement-avec-des-frames",
    "href": "formation/chapitre6.html#appariement-avec-des-frames",
    "title": "Fusion",
    "section": "0.4 Appariement avec des frames",
    "text": "0.4 Appariement avec des frames"
  },
  {
    "objectID": "formation/chapitre6.html#transposition-avec-gtools",
    "href": "formation/chapitre6.html#transposition-avec-gtools",
    "title": "Fusion",
    "section": "1.3 Transposition avec gtools",
    "text": "1.3 Transposition avec gtools"
  },
  {
    "objectID": "formation/chapitre0.html",
    "href": "formation/chapitre0.html",
    "title": "Présentation",
    "section": "",
    "text": "N’intéressera peut-être pas les utilisatrices et utilisateurs aguerri.e.s à Stata…. quoique. On trouve toujours des années plus tard des nouvelles commandes qui facilitent vraiment les choses, ou une introduction aux frames, qui revisitent les appariements de bases.\nLes chapitres sont téléchargeables en format docx.\nMaj dela formation:\n\n28/07/22 : Les variables. Chapitre 5 [todo: faire un topo sur les formats date avant fin 2023]\n07/10/22 : Introduction. Chapitre 1\n07/10/22 : L’environnement. Chapitre 2\n22/02/23 : Le langage Stata. Chapitre 3\n22/02/23 : Les bases de données. Chapitre 4 [introduction aux frame introduites avec la v16]\n05/07/23 : Opérations sur les bases de données. Chapitre 6 [début reprise du chapitre]\n\nProgrammes des chapitres:\n\nChapitre3\nChapitre4\nChapitre5\nChapitre6"
  },
  {
    "objectID": "formation/chapitre.html",
    "href": "formation/chapitre.html",
    "title": "Opérations sur les bases",
    "section": "",
    "text": "Salut"
  }
]