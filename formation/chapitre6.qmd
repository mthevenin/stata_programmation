---
title: "Opérations sur les bases"

format: 
  html: default
  docx:
    toc: true

jupyter: nbstata
---





# **Fusion de bases**

- Deux types de fusions:
  - La fusion verticale non controlée - empilement - (`append`)
  - la fusion horizontale contrôlée - appariement - (`merge`).  


## Append 

- Consiste simplement à ajouter des observations entre plusieurs bases, avec ou non un même jeu de variables. 

![](img6/img1.png)


On va générer les deux bases de données avec la commande `input` (non traité dans cette formation: `help input`). 


```{stata}
clear 
input str6 id v1 v2
  "A" 8 2 
  "B" 1 2 
  "C" 2 4
end

list

save base1, replace
```

```{stata}
clear 
input str20 id v1 v2 v3
  "D" 2 5 10
  "E" 12 1 8 
end
list

save base2, replace
```



La syntaxe de la commande `append` consiste à ajouter une ou plusieurs bases à la base active avec l'argument `using`.  

```{stata}
append using base1
sort id
list
```

On peut sélectionner les variables de la base qui sera empilée à la base active avec l'option `keep`.   
Dans l'exemple, si la base active est *base1*, on peut ne pas vouloir ajouter la variable *v3* seulement renseignée pour les observations de *base2*.

```{stata}
use base1, clear
append using base2, keep(id v1 v2)
list 
```


Si les informations précédentes étaient ventilées dans trois bases, une par variable *v*, et avec le même niveau d'observation (A,B,C,D,E dans les 3 bases), l'utilisation  de `append` conduirait à une structure empilée non souhaitable avec une réplication des *id*.

Pour obtenir la base finale proprement appariée, il convient de faire une fusion horizontale contrôlée par une une clé d'identification.


## Merge

Stata demande que les bases soient soit triées (`sort`) sur la clé d'appariement en amont de l'opération. Sinon un message d'erreur sera renvoyé.  


* La base active (ouverte) est appelée **base master**
* La base qui sera appariée à la base ouverte est appelée base **using** ^[Cela peut être plusieurs bases.]


**Syntaxe minimale 1 avec préfixe**:  
```markdown
merge [1:1] [1:m] [m:1] id_variables(s) using nom_base
```


* Ici on peut apparier plus de deux bases. 
* On ne dispose pas de sécurité, si les niveau d'identification sont différents. 


### Même niveau d'identification

Partons des informations suivantes: 
- *Base1* comprend la variable d'identification *id* (observations A,B,C) et de deux variables numériques *v1* et *v3*
- *Base2* comprend la même variable d'identification *id* (observations B,C,D) et de la variable numérique *v3*

![](img6/img3.png)
Le niveau d'identification est identique dans les deux bases. Il s'agit donc d'un **`merge 1:1`**  [one to one]

On va de nouveau générer les bases avec `input`.  

```{stata}
clear 
input str1 id v1 v2 
"A" 8 2 
"B" 1 2
"C" 2 4 
end
list

sort id
save base1, replace
```

Rappel: bien faire le `sort` sur la base using

```{stata}
clear
input str1 id v3 
"B" 10 
"C" 8
"D" 10 
end
list

sort id
save base2, replace 
```


```{stata}
merge 1:1 id using base1
```

* L'output affiche le résultat de l'appariement à l'aide d'un tableau.
* Une variable, **`_merge`**, est générée. Elle permettra de filtrer si nécessaire les observations selon le résultat de l'aapriement. Contrairement à d'autres application, cette opération n'est pas effectuée en amont avec des fonctions où des options spécifiques. Par exemple avec R: `left_join`, `right_join`, `inner_join`.
  `_merge = 1` : observations qui se trouvent seulement dans la base active (master)
  `_merge = 2` : observations qui se trouvent seulement dans la base using (appariée)
  `_merge = 3` : observations communes aux bases master et using.
* Les variables de la base master/active sont positionnées en tête.


```{stata}
sort id
list
```

Si on souhaite seulement  conserver les observations communes aux deux bases (`_merge=3`): 

```{stata}
keep if _merge==3
list
```

::: callout-warning

## Variable _merge et appariement successif

Pensez à supprimer la variable _merge si plusieurs opérérations d'appariement sont effectués. La commande ne prévoit pas 
d'écraser la variable du merge précédent.
:::

**Situation avec plus d'une base à apparier**

On ne peux pas utiliser la syntaxe avec préfixe (ici `merge 1:1`). 

On va ajouter une nouvelle base qui sera appariée avec les deux premières, qui seront donc les deux bases de type *using*.

```{stata}
clear
input str1 id str3  v4 
"A" "Non" 
"B" "Oui" 
"C" "Oui" 
end

list 

sort id
```

```{stata}
merge id using base1 base2

order id v1 v2 v3 v4 _merge1 _merge2 _merge 

list
```

On obtient maintenant 3 variables _merge:  

* _merge1. Donne le résultat de l'appariement entre la nouvelle base et *base1*: 0 si seulement dans une seule des deux bases (D), 1 si dans les deux bases (A,B,C).
* _merge2. Donne le résultat de l'appariement entre la nouvelle base et *base2*: 0 si seulement dans une seule des deux bases (A,D), 1 si dans les deux bases (B,C). 
* _merge. Résume rapidement le matching entre les bases: on retrouve au moins une fois les observations (A,B,C) dans l'un des deux appariement (_merge=3), on trouve une observation (D) qui ne se trouve que dans une base *using* (_D_merge=2).  

Si l'on souhaite conserver les observations communes aux trois bases, on peut sommer les valeurs de _merge1 et _merge2 et conserver les observations dont la valeurs de cette somme est égale au nombre d'appariements; ou faire une sélection des observations avec un filtre conditionnel, ici: 

```{stata}
keep if _merge1==1 & _merge2==1
list

drop _merge*
```


::: callout-tip

## Commande join du package ftools

[A tester] 

- [Documentation](https://github.com/sergiocorreia/ftools). 
- Permet de gagner 70% de durée d'exécution lorsque la volumétrie dépasse 100000 observations
- Gère en amont le tri des bases appariée.

:::

### Niveaux d'identification différents

Un merge de type 1:1 n'est pas possible. Dans l'exemple qui suit la base *period_act* liste pour deux personnes le statut d'activité observé pour plusieurs périodes soit des observations multiples pour chaque individus, et la base *sexe* donne une caractéristique unique pour chaque individu. Selon le statut des bases appariée (maste ou using), l'appariement est de type 1:m ou m:1.

- Si la base active est à observations multiple sur la clé d'identification: m:1
- Si la base active est à observation unique sur la clé d'identification: 1:m


![](img6/img2.png)


On va de nouveau générer les données avec `input`

```{stata}
clear 
input id périodes str8 Activité
1 1 "Emploi"
1 2 "Emploi"
1 3 "Chômage"
2 1 "Chômage" 
2 2 "Chômage"
2 3 "Emploi"
2 4 "Chômage" 
end 
list 
sort id 
save "period_act", replace
```
```{stata}
clear
input id str6 sexe 
1 "Homme"  
2 "Femme"  
end 
list
sort id 
save "sexe", replace
```

Si on faisait un merge 1:1, Stata renverrai le message d'erreur suivant:

```markdown
merge 1:1 id using activités

variable id does not uniquely identify observations in the using data
r(459);
```

Ici la base active est la base *sex*. Le prefixe qui doit être utilisé est donc **`1:m`** ^[**`m:1`** renvoit un message d'erreur. Dans ce sens, la base active doit être *period_act* et la base using *sexe*.]

```{stata}
merge 1:m id using period_act
sort id période
list 
```


::: callout-tip
Le tri de la base est régulièrement modifié après ce type d'appariement. Penser donc à retrier les données proprement, surtout quand il s'agit comme ici d'informations biographiques (`sort id périodes`)
:::


De nouveau les préfixes sont optionnels, et permettent seulement de contrôler l'appariement. On peut sans soucis fusionner des informations contextuelles avec des informations multiples avec seulement `merge`.

```{stata}
use sexe, clear
merge id using period_act
sort id périodes
list
```

### Appariement avec des frames

Pour les personnes qui n'ont jamais manipulé des frames (introduction Stata 16), se reporter à l'aide Stata (`help frame`) ou à ce [court article](https://mthevenin.github.io/stata_fr/articles/index/posts/frame/frame.html).

L'utilisation des frames présentent plusieurs avantages:  

- Il n'est pas nécessaire de trier les bases concernées par l'appariement.
- On peut sélectionner avec la commande `frget` la ou les variables qui seront récupérées dans la base master. On apparie donc pas des bases en tant que telles, on récupère de l'information de frames liées.
- Mieux encore, on peut réaliser des opérations entre observations individuelles et observations contextuelles sans passer par un appariement.   Avec les frames, l'opération d'appariement doit être plutôt compris comme un système de liaison entre bases,le transfert d'informations n'étant qu'une opération optionnelle. 

Au niveau des désavantages:   

- Si on ne travaille pas exclusivement sous frames, on devra transformer les bases en frame (voir exemple)
- Absence de variable de type _merge, qui permet de contrôler le résultat de l'appariement.
- les prefixes sont 1:1 et m:1. Cela signifie dans le second cas que la frame active lors de l'opération de liaison doit toujours être celle dont la clé d'identification est de type multiple (niveau individuel).
- Peut-être le plus embêtant est l'absence d'appariement pour les informations correspondant à **merge=2** (informations seulement présentes dans la base using). Le dernier exemple illustre ce point.


On reprend l'exemple précédent, en transformant dans un premier temps les deux bases en frames.  


```{stata}
frame reset

frame create period_act
frame period_act: use period_act
frame create sexe
frame sexe: use sexe

frame dir
```

On doit se positionner sur la frame *period_act* (type m)

```{stata}
frame change period_act
```

Pour lier les frames on utilise la commande `frlink`.  

**Syntaxe**  

```markdown
frlink 1:1/m:1 id_variable(s), frame(nom_frame) gen(variable_lien)
```

Ici on fait un appariement de type m:1, la clé d'identification est de nouveau *id*. On lie la frame active à la frame *sexe* et la variable de liaison (ici un alias de la variable id) est appelée *link*.

```{stata}
frlink m:1 id, frame(sexe) gen(link)
```

Pour importer la variable sexe dans la frame *period_act*, on utilise la commande **`frget`**, en précisant la ou les variable que l'on souhaite récupérer, ainsi que la variable de liaison (une même frame peut avoir plusieurs liaisons. Voir plus loin).

```{stata}
frget sexe , from(link)

frame period_act: order link, last
list
```


::: callout-warning

## Liaison des frames en présence d'information incomplète  

La liaison de frames peut être problématique en présence d'informations incomplètes. Pour faire simple la liaison des frames permet de faire des appariements de type merge=1 et merge=3 (présence dans master seulement / présence dans master et using) mais ne permet pas de récupérer des informations présentes seulement dans la base using).  

Pour illustrer cela on va génére une nouvelle framme, de type individu période, avec une variable additionnelle *tvc*.  

- Pour id= 1, on a pas d'information dans la frame *period_act* pour période=4
- Pour id= 2, on a pas d'information dans la frame *tvc* pour les périodes 3 et 4.  

Création de la nouvelle frame (voir le .do, la compilation pour générer ce support complexifie un peu l'opération):  

```{stata}
frame create tvc
frame change tvc


clear
input id périodes tvc 
1 1 0   
1 2 0   
1 3 1  
1 4 0  
2 1 1  
2 2 0 
end

list 

save tvc, replace
frame tvc: use tvc

```

Liaison des frames et récupération de la variable tvc dans *period_act*  

```{stata}
frame change period_act
frlink 1:1 id périodes, frame(tvc) gen(link2)

frget tvc, from(link2)

list
```

On voit bien que la valeur de tvc pour id=1 et périodes=4 n'a pas été importée (_merge=2 dans un appariement classique). En revanche, pour id=2, l'incomplétude de l'information dans la base *tvc* pour les périodes 3 et 4 est bien visible.  


Avec un merge classique (on suppose que *period_act* n'a pas été appariée à *sexe*): 

```{stata}
use tvc, clear
sort id périodes
save tvc, replace
use period_act, clear
sort id périodes
merge 1:1 id périodes using tvc
sort id périodes
list
```

On a bien ici l'ajout de l'information correspondant à _merge=2 (*Using only*)

:::

Un des intérêts des frames, est de faire des opérations entre informations individuelles et contextuelles sans passer par un appariement en amont. Par l'exemple, nous allons voir comment un appariement peut être évité lorsqu'on travaille sur ce genre d'information.  


On va générer 2 bases, une individuelle et une contextuelle. La première contient un identifiant individuelle (*id*), le nom de la zône d'appartenance (*zone*) et les valeurs observéd d'une variable *x*. La seconde contient le nom de la zône et la valeur moyenne de la variable x dans cet espace.  

Création des frames: 

```{stata}
frame reset 

clear 
input id str6 zone x
1 "zoneA" 10
2 "zoneA" 15
3 "zoneB" 9
4 "zoneB" 12
5 "zoneB" 10
6 "zoneB" 15
7 "zoneC" 6
8 "zoneC" 13
9 "zoneC" 16
end
list
save indiv, replace
```

```{stata}
clear
input str6 zone xmean
"zoneA" 11
"zoneB" 12
"zoneC" 13
end
list
save zone, replace
```

```{stata}
frame create indiv
frame indiv: use indiv
frame create zone
frame zone: use zone
```

Après avoir lié les deux frames (m:1), on va calculer directement la différence entre la valeur observée pour chaque individu de la variable *x* et sa moyenne par zone (*xmean*). On utilise la fonction **`frval`** comme argument de la commande **`generate`**.  

```{stata}
frame change indiv
frlink m:1 zone, frame(zone) gen(link)
list
```


```markdown
gen = var1 - frval(nom_link, var2)
```

```{stata}
gen diffx = x - frval(link, xmean)
list
```


[05-07-2023]

# **Transposition d'une base** 
























