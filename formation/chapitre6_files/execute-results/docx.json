{
  "hash": "635d10cffc7fbe519369de58f9c83cef",
  "result": {
    "markdown": "---\ntitle: Opérations sur les bases\nformat:\n  html: default\n  docx:\n    toc: true\n---\n\n# Fusion\n\n- Deux types de fusions:\n  - La fusion verticale non controlée - empilement - (`append`)\n  - la fusion horizontale contrôlée - appariement - (`merge`).  \n\n\n## Append\n\n- Consiste simplement à ajouter des observations entre plusieurs bases, avec ou non un même jeu de variables. \n\n![](img6/img1.png)\n\n\nOn va généré les deux bases de données avec la commande `input` (non traité dans cette formation: `help input`)\n\n::: {.cell execution_count=1}\n``` {.stata .cell-code}\nclear \ninput str6 id v1 v2\n  \"A\" 8 2 \n  \"B\" 1 2 \n  \"C\" 2 4\nend\n\nlist\n\nsave base1, replace\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n     +--------------+\nfile base1.dta saved\n```\n:::\n:::\n\n\n::: {.cell execution_count=2}\n``` {.stata .cell-code}\nclear \ninput str20 id v1 v2 v3\n  \"D\" 2 5 10\n  \"E\" 12 1 8 \nend\nlist\n\nsave base2, replace\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\n     +-------------------+\n     | id   v1   v2   v3 |\n     |-------------------|\n  1. |  D    2    5   10 |\n  2. |  E   12    1    8 |\n     +-------------------+\nfile base2.dta saved\n```\n:::\n:::\n\n\nLa syntaxe de la commande `append` consiste à ajouter une ou plusieurs bases à la base active avec l'argument `using`.  \n\n::: {.cell execution_count=3}\n``` {.stata .cell-code}\nappend using base1\nsort id\nlist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n     +-------------------+\n     | id   v1   v2   v3 |\n     |-------------------|\n  1. |  A    8    2    . |\n  2. |  B    1    2    . |\n  3. |  C    2    4    . |\n  4. |  D    2    5   10 |\n  5. |  E   12    1    8 |\n     +-------------------+\n```\n:::\n:::\n\n\nOn peut sélectionner les variables de la base qui sera empilée à la base active avec l'option `keep`.   \nDans l'exemple, si la base active est *base1*, on peut ne pas vouloir ajouter la variable *v3* seulement renseignée pour les observations de *base2*.\n\n::: {.cell execution_count=4}\n``` {.stata .cell-code}\nuse base1, clear\nappend using base2, keep(id v1 v2)\nlist \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(variable id was str6, now str20 to accommodate using data's values)\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n  4. |  D    2    5 |\n  5. |  E   12    1 |\n     +--------------+\n```\n:::\n:::\n\n\nSi les informations précédentes étaient ventilées dans trois bases, une par variable *v*, et avec le même niveau d'observation (A,B,C,D,E dans les 3 bases), l'utilisation  de `append` conduirait à une structure empilée non souhaitable avec une réplication des *id*.\n\n\n\nPour obtenir base finale proprement appariée, il convient de faire une fusion horizontale contrôlée par une une clé d'identification.\n\n\n## Merge\n\n* Fusion contrôlée par une clé d’appariement (variable(s))\n* Un merge peut réaliser un empilement (`append`), mais pas l’inverse.\n* La commande usine est **`merge`**. Pour contrôler des niveaux d’identification différents on peut y ajouter `1:1`, `1:m`, `m:1` ou `m:m` (le dernier prefixe estrarement ou jamais utiliser)\n* Depuis Stata 16 on peut réaliser des merge en transformant les bases en **frame**. Cette solution est très adapté aux appariements de données individuelles avec des données contextuelles. Cette solution sera traitée plus bas.\n\n::: callout-important\n\nStata demande que les bases soient soit triées (`sort`) sur la clé d'appariement en amont de l'opération. Sinon un message d'erreur sera renvoyé.  \n:::\n\n* La base active (ouverte) est appelée **base master**\n* La base qui sera appariée à la base ouverte est appelée base **using** ^[Cela peut être plusieurs bases.]\n\n\n**Syntaxe minimale**:  \n```markdown\nmerge [1:1] [1:m] [m:1] id_var using noms_bases\n```\n\n\nPartons des informations suivantes: \n- *Base1* comprend la variable d'identification *id* (observations A,B,C) et de deux variables numériques *v1* et *v3*\n- *Base2* comprend la même variable d'identification *id* (observations B,C,D) et de la variable numérique *v3*\n\n![](img6/img3.png)\nLe niveau d'identification est identique dans les deux bases. Il s'agit donc d'un **`merge 1:1`**  [one to one]\n\nOn va de nouveau générer les bases avec `input`.  \n\n::: {.cell execution_count=5}\n``` {.stata .cell-code}\nclear \ninput str1 id v1 v2 \n\"A\" 8 2 \n\"B\" 1 2\n\"C\" 2 4 \nend\nlist\n\nsort id\nsave base1, replace\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\n     +--------------+\n     | id   v1   v2 |\n     |--------------|\n  1. |  A    8    2 |\n  2. |  B    1    2 |\n  3. |  C    2    4 |\n     +--------------+\nfile base1.dta saved\n```\n:::\n:::\n\n\nRappel: bien faire le `sort` sur la base using\n\n::: {.cell execution_count=6}\n``` {.stata .cell-code}\nclear\ninput str1 id v3 \n\"B\" 10 \n\"C\" 8\n\"D\" 10 \nend\nlist \nsave base2, replace \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\n     +---------+\n     | id   v3 |\n     |---------|\n  1. |  B   10 |\n  2. |  C    8 |\n  3. |  D   10 |\n     +---------+\nfile base2.dta saved\n```\n:::\n:::\n\n\nPour l'appariement, de nouveau faire le tri\n\n::: {.cell execution_count=7}\n``` {.stata .cell-code}\nsort id\n\nmerge 1:1 id using base1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n    Result                      Number of obs\n    -----------------------------------------\n    Not matched                             2\n        from master                         1  (_merge==1)\n        from using                          1  (_merge==2)\n\n    Matched                                 2  (_merge==3)\n    -----------------------------------------\n```\n:::\n:::\n\n\n* L'output affiche le résultat de l'appariement à l'aide d'un tableau.\n* Une variable, **`_merge`**, est générée. Elle permettra de filtrer si nécessaire les observations selon le résultat de l'aapriement. Contrairement à d'autres application, cette opération n'est pas effectuée en amont avec des fonctions où des options spécifiques. Par exemple avec R: `left_join`, `right_join`, `inner_join`.\n  `_merge = 1` : observations qui se trouvent seulement dans la base active (master)\n  `_merge = 2` : observations qui se trouvent seulement dans la base using (appariée)\n  `_merge = 3` : observations communes aux bases master et using.\n* Les variables de la base master/active sont positionnées en tête.\n\n::: {.cell execution_count=8}\n``` {.stata .cell-code}\nsort id\nlist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n     +-------------------------------------+\n     | id   v3   v1   v2            _merge |\n     |-------------------------------------|\n  1. |  A    .    8    2    Using only (2) |\n  2. |  B   10    1    2       Matched (3) |\n  3. |  C    8    2    4       Matched (3) |\n  4. |  D   10    .    .   Master only (1) |\n     +-------------------------------------+\n```\n:::\n:::\n\n\nSi on souhaite conserver que les observations communes aux deux bases (`_merge=3`): \n\n::: {.cell execution_count=9}\n``` {.stata .cell-code}\nkeep if _merge==3\nlist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(2 observations deleted)\n\n     +---------------------------------+\n     | id   v3   v1   v2        _merge |\n     |---------------------------------|\n  1. |  B   10    1    2   Matched (3) |\n  2. |  C    8    2    4   Matched (3) |\n     +---------------------------------+\n```\n:::\n:::\n\n\n![](img6/img2.png)\n\n",
    "supporting": [
      "chapitre6_files\\figure-docx"
    ],
    "filters": []
  }
}