[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Marc Thévenin",
    "section": "",
    "text": "Liens Ined\n\n\n\n\nSite de l’Ined: \nSite du Service Méthodes Statistiques: \n\nSite des Rencontres de Statistique Appliquée: \n\nSite du séminaire R à l’Usage des Sciences Sociales (RUSS): \n\n\n\n\n\n\n\n\n\nAutres supports\n\n\n\n\nFormation analyse des durées (2017-2020): https://mthevenin.github.io/analyse_duree/\nFormation introduction à Stata (2018): datée - mise à jour en cours: https://mthevenin.github.io/formation_stata/"
  },
  {
    "objectID": "formation/chapitre0.html",
    "href": "formation/chapitre0.html",
    "title": "Présentation",
    "section": "",
    "text": "MAJ EN COURS DE LA VERSION 2018 [nouvelle version fin 2022 au mieux]\n\nN’intéressera sûrement pas les utilisatrices et utilisateurs aguerri.e.s à Stata…. quoique, on trouve toujours des années plus tard des nouvelles commandes qui facilite vraiment les choses, par exemple sur la rapide reprise du chapitre 5, la commande sencode (s pour super).\nUn document pdf sera mis à disposition au fil des maj\nLa fin de la maj de la formation est programmée pour la fin 2022 (donc prévoir un dépassement), cela devrait (pourrait) aller assez vite\nDébut Maj (28:07) : chapitre 5 (variables) => commande sencode (hélas découverte récemment), ajout d’une section sur les variables de type date\n\n\nBlocks de programme\n\nPROGRAMME\n\n\nRESULTAT DANS L'OUTPUT"
  },
  {
    "objectID": "formation/chapitre5.html",
    "href": "formation/chapitre5.html",
    "title": "Les variables",
    "section": "",
    "text": "[MAJ EN COURS]\nProgramme du chapitre\nCommandes et fonction introduites\nEn italique, commandes externes\nEn italiques, commandes externe Pour accéder aux infomations sur les variables d’une base:\nVariables manager\nFenêtre properties à droite de l’interface principale (mode dévérouillé)\nCommande describe"
  },
  {
    "objectID": "formation/chapitre5.html#types",
    "href": "formation/chapitre5.html#types",
    "title": "Les variables",
    "section": "Types",
    "text": "Types\nStata gère tous les types de variables: numérique, caractère, date. Un type de variable est un type de stockage.\n\nTypes numériques: float, long, double, int et byte.\nTypes caractère: str# et strL (très grandes chaînes de caractères). # est la longueur de la chaîne de caractère, elle ne peut pas excéder 2046 pour le type str.\n\nPlus d’informations: help data types\nModification du type de variable\n\nOptimisation du poids en mémoire avec compress\nCommande recast\n\nOptimisation du poids de la base\n\ncompress \n\n\nvariable mpg was int now byte\nvariable rep78 was int now byte\nvariable trunk was int now byte\nvariable turn was int now byte\nvariable make was str18 now str17\n  \n(370 bytes saved)\n\nPassage de la variable make en str3\nEn réduisant le type, on va tronquer les chaînes de caractères qui ne garderont que les 3 premières lettres, à manupiler avec prudence donc. Pour cette opération, Stata impose une confirmation avec l’option force.\nVariable d’origine\n\ndes make \nlist make in 1/10\n\n\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n------------------------------------------------------------\nmake            str18   %-18s                 Make and model\n\n\n     +---------------+\n     | make          |\n     |---------------|\n  1. | AMC Concord   |\n  2. | AMC Pacer     |\n  3. | AMC Spirit    |\n  4. | Buick Century |\n  5. | Buick Electra |\n     |---------------|\n  6. | Buick LeSabre |\n  7. | Buick Opel    |\n  8. | Buick Regal   |\n  9. | Buick Riviera |\n 10. | Buick Skylark |\n     +---------------+\n\nModification du type\n\nrecast str3 make, force\ndes make\nlist make in 1/10\n\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n------------------------------------------------------------\nmake            str3    %-9s                  Make and model\n\n     +------+\n     | make |\n     |------|\n  1. | AMC  |\n  2. | AMC  |\n  3. | AMC  |\n  4. | Bui  |\n  5. | Bui  |\n     |------|\n  6. | Bui  |\n  7. | Bui  |\n  8. | Bui  |\n  9. | Bui  |\n 10. | Bui  |\n     +------+"
  },
  {
    "objectID": "formation/chapitre5.html#format",
    "href": "formation/chapitre5.html#format",
    "title": "Les variables",
    "section": "Format",
    "text": "Format\nIl s’agit du format d’affichage des valeurs des variables. Ils peuvent être modifiés sans que le type soit changé (décimales, alignement….).\nVariables numérique:\n- format g: général (définition un peu obsure pour moi) - format f: fixe - plusieurs format d’affichage pour les variables de type dates: %td (date avec jour-mois-année), %tm (mois), %tq (trimestre), %tw (semaine). Les dates et leur manipulation sont un domaines très riche, et feront l’objet d’une courte présentation en fin de chapite.\nOn peut changer le format d’affichage avec la commande format. Si le format est de type général (g), il est préférable de passer à un format de type fixe (f) On peut un même format à une liste de variables.\n\nformat %format varlist\n\nExemple: changement du nombre de décimales\nDans la base auto, la variable gear_ratio est de format fixe à 2 décimales (%6.2f). Pour supprimer, à l’affichage, les deux décimales: afficher les valeurs sans décimales.\n\nlist gear_ratio in 1/10\n\n\n     +----------+\n     | gear_r~o |\n     |----------|\n  1. |     3.58 |\n  2. |     2.53 |\n  3. |     3.08 |\n  4. |     2.93 |\n  5. |     2.41 |\n     |----------|\n  6. |     2.73 |\n  7. |     2.87 |\n  8. |     2.93 |\n  9. |     2.93 |\n 10. |     3.08 |\n     +----------+\n\n\nformat %6.0f gear_ratio\n\n\n     +----------+\n     | gear_r~o |\n     |----------|\n  1. |        4 |\n  2. |        3 |\n  3. |        3 |\n  4. |        3 |\n  5. |        2 |\n     |----------|\n  6. |        3 |\n  7. |        3 |\n  8. |        3 |\n  9. |        3 |\n 10. |        3 |\n     +----------+\n\nExemple: aligner le nombre décimal reporté avec summarize sur le format de la variable\nAvec l’option format appliquée à la commande summarize on peut automatiquement réduire le nombre de décimales reportées dans l’output\n\nsum gear_ratio\nsum gear_ratio, d\n\n\n\n    Variable |        Obs        Mean    Std. dev.       Min        Max\n-------------+---------------------------------------------------------\n  gear_ratio |         74    3.014865    .4562871       2.19       3.89\n\n\n                         Gear ratio\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%         2.19           2.19\n 5%         2.28           2.24\n10%         2.43           2.26       Obs                  74\n25%         2.73           2.28       Sum of wgt.          74\n\n50%        2.955                      Mean           3.014865\n                        Largest       Std. dev.      .4562871\n75%         3.37           3.78\n90%         3.72           3.78       Variance       .2081979\n95%         3.78           3.81       Skewness       .2191658\n99%         3.89           3.89       Kurtosis       2.101812\n\nAvec l’option format\n\nsysuse auto, clear\n\nsum gear_ratio format\nsum gear_ratio, d format\n\n\n    Variable |        Obs        Mean    Std. dev.       Min        Max\n-------------+---------------------------------------------------------\n  gear_ratio |         74        3.01        0.46       2.19       3.89\n\n                         Gear ratio\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%         2.19           2.19\n 5%         2.28           2.24\n10%         2.43           2.26       Obs                  74\n25%         2.73           2.28       Sum of wgt.          74\n\n50%         2.96                      Mean               3.01\n                        Largest       Std. dev.          0.46\n75%         3.37           3.78\n90%         3.72           3.78       Variance           0.21\n95%         3.78           3.81       Skewness           0.22\n99%         3.89           3.89       Kurtosis           2.10"
  },
  {
    "objectID": "formation/chapitre5.html#modification-du-type",
    "href": "formation/chapitre5.html#modification-du-type",
    "title": "Les variables",
    "section": "Modification du type",
    "text": "Modification du type\nIl est possible de basculer d’un type caractère à un type numérique et inversement\nDe numérique à caractère\n Si la variable numérique n’a pas de label affecté sur les modalités, ou qu’on ne veut pas conserver l’information données par les labels, on peut utiliser la commande tostring. On peut créer une nouvelle variable avec l’option gen() ou remplacer la variable numérique d’origine avec l’option replace. Une des deux options doit être nécessairement renseignée.\n\n  tostring [varlist], gen(nom_varlist)\n  tostring [varlist], replace\n\nExemple avec la variable foreign qui prend les valeur 0 et 1 avec les labels “domestic” (0) et “foreign” (1)\n\ntostring foreign, gen(foreign_str)\ndes foreign foreign_str\n\ntab foreign foreign_str\n\n\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n------------------------------------------------------------\nforeign         byte    %8.0g      origin     Car origin\nforeign_str     str1    %9s                   Car origin\n\n\n           |      Car origin\nCar origin |         0          1 |     Total\n-----------+----------------------+----------\n  Domestic |        52          0 |        52 \n   Foreign |         0         22 |        22 \n-----------+----------------------+----------\n     Total |        52         22 |        74 \n\nSi la variable numérique a des labels affectés aux modalités modalités et qu’on souhaite conserver cet information, on utilise la commande decode\n\n  decode variable, gen(nom_var)\n\nExemple avec la variable foreign\n\ndecode foreign, gen(foreign_str)\n\ndes foreign foreign_str\n\ntab foreign_str\n  \n\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n---------------------------------------------------------------------------------------------------------------------------------------------------\nforeign         byte    %8.0g      origin     Car origin\nforeign_str     str8    %9s                   Car origin\n\n\n Car origin |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   Domestic |         52       70.27       70.27\n    Foreign |         22       29.73      100.00\n------------+-----------------------------------\n      Total |         74      100.00\n\n\nDe caractère à numérique\nSi la variable caractère est a une forme numerique (une suite de nombre comme des années, des âges…), on utilise la commande destring. Lorsqu’il y a des des valeurs manquantes à la variable, on doit uiliser l’option force.\n\n destring [varlist] , gen(nom_varlist) \n destring [varlist] , replace [force]\n\nExemple avec la variable rep78 qui est transformé dans un premier temps en variables caractère avec tostring puis de nouveau transformé en format numérique avec destring\n\ntostring rep78, replace\n\ndestring rep78, replace\n\nSi la variable caractère n’est pas de forme numérique et que l’on souhaite récupérer les labels sur les modalités, on peut utiliser la commande encode ou la commande externe sencode (net install st0043_2, force). La seconde permet de remplacer directement la variable d’origine, option particulièrement pratique.. Egalement, cette commande permet plus de souplesse sur le codage de la variable (help sencode pour plus de détail).\nAvec encode ou sencode sans l’option gsort, le numéro de la modalité suivra l’ordre alphabétique des chaînes de caractère de la variable: si la variable caractère à pour valeur (“Homme”, “Femme”), “femme” sera automatiquement codée 1 et “homme” 2.\n\nencode variable, gen(nom_variable)\n\n\nsencode variable, gen(nom_variable) replace gsort()\n\nExemple avec la variable foreign_str (variable caractère créée précédemment à partir de la variable foreign)\n\nencode foreign_str, gen(foreign2)\n\ntab foreign2\ntab foreign2, nolab\n\n\n Car origin |      Freq.     Percent        Cum.\n------------+-----------------------------------\n   Domestic |         52       70.27       70.27\n    Foreign |         22       29.73      100.00\n------------+-----------------------------------\n      Total |         74      100.00\n\n\n Car origin |      Freq.     Percent        Cum.\n------------+-----------------------------------\n          1 |         52       70.27       70.27\n          2 |         22       29.73      100.00\n------------+-----------------------------------\n      Total |         74      100.00\n\n\n\n\n\n\n\n\n\nType de variable pour les modèles\n\n\n\nLes variables de type caractères ne sont pas acceptées, Stata renvoie alors un message d’erreur avec no observation. Si c’est le cas, les commandes destring et encode vont s’avérer particulièrement utiles."
  },
  {
    "objectID": "formation/chapitre5.html#generate---replace",
    "href": "formation/chapitre5.html#generate---replace",
    "title": "Les variables",
    "section": "generate - replace",
    "text": "generate - replace\nLa création d’une nouvelle variable se fait avec la commande generate généralement tronquée jusqu’à gen.\nSyntaxe:\n\ngen nom_variable=valeur/fonction [expression: if in inlist inrange...]\n\nPour remplacer la valeur d’une valeur variable existante on utilise la commande replace. Le nom n’est malheureusement pas tronquable.\nSyntaxe:\n\nreplace nom_variable=valeur/fonction [expression: if in inlist inrange...]\n\n\nOn peut utiliser le préfixe bysort\nPour utiliser une fonction mathématique (log, exp, .) => help math_functions\nPour afficher la liste complète des fonctions (variables caractères, statistiques, pseudo nombre aléatoire, dates.): help function\n\nRappel: attention entre l’opérateur d’affectation (=) et l’expression conditionnelle (==).\n\nCréation d’une indicatrice (0,1)\n On peut rapidement générer des indicatrices (0,1) à partir d’une expression conditionnelle:\n\ngen x= expression_conditionnelle\n\nExemple avec la variable rep78. On génère la variable rep2 qui prend la valeur 1 si rep78>3, 0 sinon. Comme il y a des valeurs manquantes dans la variable d’origine, on corrige l’information pour l’indicatrice dont les valeurs manquantes ont été automatiquement affectées à la valeur 0.\n\ngen rep2 = rep78>3 & rep78<.\nreplace rep2 = . if rep78==.\ntab rep78 rep2\n\n\n   Repair  |\n    record |               rep2\n      1978 |         0          1          . |     Total\n-----------+---------------------------------+----------\n         1 |         2          0          0 |         2 \n         2 |         8          0          0 |         8 \n         3 |        30          0          0 |        30 \n         4 |         0         18          0 |        18 \n         5 |         0         11          0 |        11 \n         . |         0          0          5 |         5 \n-----------+---------------------------------+----------\n     Total |        40         29          5 |        74 \n\n\n Remarque: Avec la commande tabulate on peut créer une série d’indicatrices à partir d’une variable catégorielle avec l’option gen(nom_variable)\n\ntab x, gen(nom_variable)\n\nExemple avec la variable foreign. Avec tabulate on va générer deux indicatrices: origine1 si foreign=0, et origine2 si foreign=1. Un label à la variable est automatiquement créé indiquant la valeur de la variable d’origine.\n\ntab foreign, gen(origine)\n\ndes origine1 origine2\n\ntab origine1 foreign\ntab origine2 foreign\n\n\n\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n---------------------------------------------------------------\norigine1        byte    %8.0g                 foreign==Domestic\norigine2        byte    %8.0g                 foreign==Foreign\n\n\nforeign==  |      Car origin\n   Domestic|  Domestic    Foreign |     Total\n-----------+----------------------+----------\n         0 |         0         22 |        22 \n         1 |        52          0 |        52 \n-----------+----------------------+----------\n     Total |        52         22 |        74 \n     \n     \nforeign==  |      Car origin\n   Foreign |  Domestic    Foreign |     Total\n-----------+----------------------+----------\n         0 |        52          0 |        52 \n         1 |         0         22 |        22 \n-----------+----------------------+----------\n     Total |        52         22 |        74"
  },
  {
    "objectID": "formation/chapitre5.html#egen",
    "href": "formation/chapitre5.html#egen",
    "title": "Les variables",
    "section": "egen",
    "text": "egen\negen: extented generate\negenmore: package programmé par NJ.Cox qui ajoute des fonctions associée à egen [ssc install egenmore]\nRéservé à l’utilisation de fonctions. Pour obtenir la liste help egen.\n\nExemple: on va créer dans un premier la variable mprice qui reporte pour chaque observation la moyenne de la variable price. Dans un second temps, on va créer la variable mprice_or, mais avec le prix moyen des voitures selon leur origine (foreign). La fonction utilisée est la fonction mean().\n\negen mprice = mean(price)\n\nlist  make price mprice in 1/10\n\n\n    +-----------------------------------+\n     | make             price     mprice |\n     |-----------------------------------|\n  1. | AMC Concord      4,099   6165.257 |\n  2. | AMC Pacer        4,749   6165.257 |\n  3. | AMC Spirit       3,799   6165.257 |\n  4. | Buick Century    4,816   6165.257 |\n  5. | Buick Electra    7,827   6165.257 |\n     |-----------------------------------|\n  6. | Buick LeSabre    5,788   6165.257 |\n  7. | Buick Opel       4,453   6165.257 |\n  8. | Buick Regal      5,189   6165.257 |\n  9. | Buick Riviera   10,372   6165.257 |\n 10. | Buick Skylark    4,082   6165.257 |\n     +-----------------------------------+\n\n\nbysort foreign: egen mprice_or = mean(price)\n\nlist  make price mprice in 1/5\nlist  make price mprice in 66/70\n\n\n     +----------------------------------------------+\n     | make            price     mprice   mprice-or |\n     |----------------------------------------------|\n  1. | AMC Concord     4,099   6165.257    6072.423 |\n  2. | AMC Pacer       4,749   6165.257    6072.423 |\n  3. | AMC Spirit      3,799   6165.257    6072.423 |\n  4. | Buick Century   4,816   6165.257    6072.423 |\n  5. | Buick Electra   7,827   6165.257    6072.423 |\n     +----------------------------------------------+\n 66. | Subaru           3,798   6165.257   6384.682 |\n 67. | Toyota Celica    5,899   6165.257   6384.682 |\n 68. | Toyota Corolla   3,748   6165.257   6384.682 |\n 69. | Toyota Corona    5,719   6165.257   6384.682 |\n 70. | VW Dasher        7,140   6165.257   6384.682 |\n     +----------------------------------------------+\n\n\n\n\n\n\n\nLes fonctions sum() et total()**\n\n\n\nSans aucune explication, la fonction sum() qui permet d’obtenir une somme incrémentale n’est pas associée à egen mais à generate. En revanche la fonction total() est associée à egen. Il faut le retenir.\nExemple: on veut créer un identifiant numérique (variable id) pour chaque voiture (dans la base on a une seule voiture par nom de voiture).\n\ngen x = 1 \ngen id = sum(x)\n\nlist id make in 1/5\nlist id make in 66/70\n\n\n     +---------------------+\n     | id   make           |\n     |---------------------|\n  1. |  1   AMC Concord    |\n  2. |  2   AMC Pacer      |\n  3. |  3   AMC Spirit     |\n  4. |  4   Buick Century  |\n  5. |  5   Buick Electra  |\n     +------------ --------+\n 66. | 66   Subaru         |\n 67. | 67   Toyota Celica  |\n 68. | 68   Toyota Corolla |\n 69. | 69   Toyota Corona  |\n 70. | 70   VW Dasher      |\n     +---------------------+\n\nSi on veut reporter le nombre total d’observations dans la base (variable N), avec la fonction total:\n\negen N = total(x)\n\nlist id N make in 1/5\nlist id N make in 66/70\n\n\n     +----------------------- --+\n     | id    N   make           |\n     |--------------------------|\n  1. |  1   74   AMC Concord    |\n  2. |  2   74   AMC Pacer      |\n  3. |  3   74   AMC Spirit     |\n  4. |  4   74   Buick Century  |\n  5. |  5   74   Buick Electra  |\n     +--------------------------+\n 66. | 66   74   Subaru         |\n 67. | 67   74   Toyota Celica  |\n 68. | 68   74   Toyota Corolla |\n 69. | 69   74   Toyota Corona  |\n 70. | 70   74   VW Dasher      |\n     +--------------------------+\n\n\n\nOn va le voir, ces deux variables qui ont été générées peuvent l’être directement avec les variables internes dites de comptage.\n\n\n\n\n\n\nPackage gegen (M.Caceres)\n\n\n\n\nPour les volumétries dépassant le million d’observation il est fortement conseillé d’utilisée les commandes associées au package de Mauricio Caceres, ici la commande gege,.\nhttps://gtools.readthedocs.io/en/latest/\nhttps://mthevenin.github.io/stata_programmation/speedup/gtools.html\n\n\n\n[maj au 01/07/2022]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmation",
    "section": "",
    "text": "Support réalisé avec Rstudio - Quarto.\n Version Stata: 17-SE"
  },
  {
    "objectID": "macro/intro.html",
    "href": "macro/intro.html",
    "title": "Présentation",
    "section": "",
    "text": "Vraisemblablement la section qui sera la plus dense, avec également des éléments de programmation d’algorithme.\nPas de contenu en mis à disposition mais on peut déjà se diriger vers le chapitre sur macros dans la formation sur les graphiques: lien\nLa première contribution sera surement sur les objets scalar. Il y a souvent des confusions entre ce type d’objets qui ne sont pas justement pas des macros mais des pseudo variables, mais dont l’utilisation peut dans certains contextes s’avérer être un bon substitut aux macros de type local dans les programmes:\n\npas d’appel par des côtes\nenregistrement sur la session et non sur le temps d’exécution"
  },
  {
    "objectID": "profile/profile1.html",
    "href": "profile/profile1.html",
    "title": "Principe",
    "section": "",
    "text": "Un fichier profile.do est un programme qui s’éxécute à l’ouverture d’une session Stata. Ce programme comporte uniquement des éléments de configuration, par exemples:\n\nCréation d’un log de session automatique. J’y tiens, un problème n’arrive pas toujours qu’aux autre.\nAffectation d’un répertoire temporaire autre que celui par défaut\nModification de la localisation du répertoire ado plus (il est conseillé mettre sur le lecteur D à l’Ined ou tout autre lecteur que le C:)\nToutes les commandes de paramétrisation préfixées par set: contrôle du défilement de l’output, affichage du nombre de décimales dans les tableaux de régression etc…\nParamètres des graphiques: thèmes, police d’affichage… Je conseille d’utiliser à minima grstyle de Ben Jann.\n\nToutes les commandes sont donc insérées dans un seule programme, il est possible de les activer, de les désactiver ou de les modifier très facilement selon l’usage du moment.\n\n\nCréation et modification d’un fichier profile.do\nLe fichier profile.do doit être impérativement enregistré dans le répertoire user:\n\n\nWindows: \"C:/Users/nom_user/\"\nLinux (serveur Margaux): \"home/Users/nom_user/\"\n\n\nUne fois le programme enregistré, son effet n’est pris en compte que pour les sessions ouvertes ultérieurement et non sur celles en cours. Le programme est chargé uniquement à l’ouverture d’une session, un message apparait dans l’output:\n\nPour faciliter l’ouverture et l’enregistrement du fichier sous windows sans avoir à se promener dans l’explorateur de fichiers, on peut enregistrer la localisation du répertoire user avec une macro de type global, ici appelée user, et l’ouvrir rapidement avec l’invite de commande windows sous Stata (! ou shell).\nAffectation du répertoire user dans une macro:\n\nglobal user \"C:/Users/nom_user/\"\n\nOuverture du fichier profile.do avec l’invite de commande:\n\n! $user/profile.do\n\n\n\nExemples\nLes quelques exemples de configurations qui suivent sont forcément orientés vers mon propre usage.\n\nadoplusRépertoire temporaireLog automatiqueCommandes de type setGraphiquesPython\n\n\nChangement de la localisation du répertoire où sont enregistrées les commandes externes. Il est préférable de les localiser dans un lecteur autre que le lecteur C:\n\nsysdir set PLUS \"D:/D/ado/plus\"\nsysdir set PERSONAL \"D:/D/ado/personal\"\n\n\n\nOn peut créer un répertoire qui fera office de répertoire d’enregistrement par défaut des fichiers, et affecter les opérations d’ouvertures et de sauvegardes dans ce répertoire.\n\n* Après création du répertoire stata_temp\ncd \"D:\\D\\stata_temp\\\"\n\nC’est très optionnel: on peut demander à Stata d’afficher à l’ouverture le contenu de ce répertoire\n\nnoisily display as txt    \"------------------------------------\"\nnoisily display as result \"  Contenu du repertoire stata_temp  \"\nnoisily display as txt    \"------------------------------------\"\nnoisily dir \"D:/D/stata_temp/\"\n\n\n\n\n\n\n\n\n\n\n\nSi on change dans un programme le répertoire d’affectation par défaut avec cd, ce répertoire stata_temp ne sera plus reconnu comme répertoire par défaut.\nPour palier ce problème on peut affecter une macro à la localisation de ce répertoire.\n\nglobal tmp \"D:/D/stata_temp/\"\n\n\ncd \"path/mon_projet\"  \n\nuse base, clear\nkeep if x==1\nsave $tmp/base_x1, replace\n\nCette solution comporte néanmoins des limites lorsque le programme est utilisé par plusieurs personnes.\n\n\nLa plus utile de toutes les configurations décrites ici.\nAu préalable, je conseille de créer un répertoire d’enregistrement pour ces fichiers logs. Je les enregistre dans un sous répertoire de stat_temp appelé tout simplement log.\n\ncapture log close statalog\nlocal cdt = \"`c(current_date)'\"\nlocal cdt: subinstr local cdt \" \" \"-\", all\nlocal cti = \"`c(current_time)'\"\nlocal cti: subinstr local cti \":\" \".\", all\nlocal statalogname \"statalog_`cdt'_`cti'.log\"\n\nlog using \"$user/stata_temp/log/`statalogname'\" , text name(statalog)\n\nPour le chemin d’accès, j’utilise le répertoire user enregistré sous forme d’une macro (voir plus haut).\nDans ce répertoire sont enregistrés tous les log de session depuis le 1er février 2022.\n\n\n\n\n\nIl n’est pas nécessaire d’ajouter l’option permanently comme le fichier profile est chargé à chaque ouverture de session.\nEnsemble des commandes préfixées par set: help set\n\n\nExemple 1: nombre de décimales reportées dans l’output d’une régression avec set cformats (coef, se et bornes ci), set sformats (statistique du test) et set pformats (p-value).\nSi on souhaite fixer le nombre de décimale pour l’ensemble des statistiques à 2\n\nset cformats %9.2f   // max longueur =9\nset sformats %9.2f   // max longueur =8\nset pformats %9.2f   // max longueur =5\n\nExemple 2: déblocage du défilement de l’output\n\nset more off\n\n\n\nDe nouveau avec une commande de type set on peut dans son fichier profile.do changer le thème par défaut avec set scheme nom_scheme.\nJ’ai maintenant pour (bonne) habitude d’utiliser grstyle de Ben Jann (présentation dans la formation dédiée aux graphiques: https://mthevenin.github.io/stata_graphiques/formation32.html#grstyle-de-b.jann).\nSelon l’humeur du moment, on peut générer un thème graphique visuellement bien plus qualitatif que les thèmes usines de Stata, avec seulement quelques arguments.\n\ngrstyle init\ngrstyle set imesh\ngrstyle set legend 11, nobox\ngrstyle set color tableau\n\nPenser à installer les packafes grstyle** et colorpalette avant.\n\n\nChargement de l’installation python\nDe nouveau on retrouve une commande de type set qui permet d’indiquer la localisation de l’exécutable python. J’ai par exemple deux installations de Python, une standard et une avec conda:\n\npython search\n\n/*\n C:\\Users\\thevenin_m\\AppData\\Local\\Programs\\Python\\Python310\\python.exe\n C:\\Users\\thevenin_m\\Miniconda3\\python.exe\n*/\n\nOn déclare l’exécutable python à Stata avec la commande set python_exec. Si on souhaite le modifier, la présence de la commande dans le fichier profile.do s’avère plutôt utile.\n\nC:/Users/thevenin_m/AppData/Local/Programs/Python/Python310/python.exe\n\nEmpêcher le bug graphique qui fait planter Stata avec Anaconda/miniconda\nL’utilisation de conda - Anaconda ou miniconda - n’est pas recommandé pour exécuter du code python dans un programme Stata. Pour preuve, sans les quelques lignes de codes qui suiven, l’exécution d’un graphique utilisant matplotlib risque de faire crasher la session Stata. C’est très désagréable. Plutôt que d’insérer ce code dans le programme, il est préférable de le mettre une bonne fois pour toute dans le profile.do si python est utilisé via conda. Mieux vaut vérifier la localisation exacte du répertoire plugins, je ne sais pas si le chemin qui suit vaut pour toutes les installation de miniconda/anaconda.\n\npython:\nimport os\nos.environ['QT_QPA_PLATFORM_PLUGIN_PATH']=\"C:\\\\Users\\\\thevenin_m\\\\Miniconda3\\\\Library\\\\plugins\\\\plugins\"\nend\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa section qui suit met a disposition mon fichier profile.do. Tout est mis en ligne de commentaire, il suffit de retirer la balise * et de modifier les chemins si nécessaire."
  },
  {
    "objectID": "profile/profile2.html",
    "href": "profile/profile2.html",
    "title": "Exemple profile.do",
    "section": "",
    "text": "**************************\n* profile.do Ined        *\n* M.Thevenin Ined-SMS    *\n**************************\n\n/* \n- Copier le programme ou une partie selon les besoins danx un .do\n- Désactiver les zônes de commentaire *\n- Enregistrer le fichier profile.do dans le répertoire unser\n- Seulement ici les paramètres que j'utilise. On peut, bien évidemment, en ajouter d'autres\n*/  \n  \n*****************************\n* ado + et personal dans D: *\n***************************** \n\n/* modifier les chemin si nécessaire */  \n  \n* sysdir set PLUS \"D:/D/ado/plus\"\n* sysdir set PERSONAL \"D:/D/ado/personal\"\n\n****************\n** STATA_TEMP **\n****************\n\n/* Créer un répertoire, pas forcément du même nom que celui ci et modifier les chemin */  \n  \n* cd \"D:\\D\\stata_temp\\\"\n\n*************************************************\n* affichage du contenu du repertoire stata_temp *\n*************************************************\n\n* noisily display as txt    \"------------------------------------\"\n* noisily display as result \"  Contenu du repertoire stata_temp  \"\n* noisily display as txt    \"------------------------------------\"\n* noisily dir \"D:/D/stata_temp/\"\n\n\n**************************************************\n* chargement du répertoire  $tmp dans stata_temp *\n**************************************************\n\n/* attention si plusieurs utilisateurs d'un même programme, le chemin de $tmp risque de ne pas être reconnu */\n\n* global tmp \"D:/D/stata_temp/\"\n\n\n\n\n******************************************\n* Creation automatique d'un fichier .log *\n******************************************\n\n/* changer le chemin à l'avant dernière ligne: log using.... */\n\n* capture log close statalog\n*  local cdt = \"`c(current_date)'\"\n* local cdt: subinstr local cdt \" \" \"-\", all\n* local cti = \"`c(current_time)'\"\n* local cti: subinstr local cti \":\" \".\", all\n* local statalogname \"statalog_`cdt'_`cti'.log\"\n\n* noisily display \"Nom du log: `statalogname'\"\n*  log using \"D:/D/stata_temp/log/`statalogname'\" , text name(statalog)\n*  noisily display \"\"\n\n\n*****************\n* R source path *\n*****************\n\n* global Rterm_path `\"C:\\Program Files\\R\\R-4.1.2\\bin\\R.exe\"'\n\n* global Rterm_options `\"--slave --vanilla --args  \"`tf1'\" \"`tf2'\" \"'\n\n\n***************************************************\n* supprimer le blocage du défilement  de l'output *\n***************************************************\n\n* set more off\n\n*******************************\n* output regression           *\n*******************************\n\n/* nombre de decimales =3 */\n\n* set cformat %9.3f\n\n/* garder baselevel*/\n\n*set showbaselevels on\n\n*******************************\n*      graphique              *\n*******************************\n\n/* Installer au préalab grstyle et colorpalette */\n\n* grstyle init\n* grstyle set imesh\n* grstyle set legend 11, nobox\n* grstyle set color tableau\n\n\n*******************************\n*      python                 *\n*******************************\n\n/* chargement de l'exécutable */\n\n* capture  set python_exec  \"C:/Users/thevenin_m/AppData/Local/Programs/Python/Python310/python.exe\"\n\n\n****** plugin miniconda\n* python:\n* import os\n* os.environ['QT_QPA_PLATFORM_PLUGIN_PATH']=\"C:\\\\Users\\\\thevenin_m\\\\Miniconda3\\\\Library\\\\plugins\\\\plugins\"\n* end"
  },
  {
    "objectID": "profile.html#adoplus",
    "href": "profile.html#adoplus",
    "title": "Principe",
    "section": "adoplus",
    "text": "adoplus\n\nsysdir set PLUS \"D:/D/ado/plus\"\nsysdir set PERSONAL \"D:/D/ado/personal\""
  },
  {
    "objectID": "profile.html#répertoire-temporaire",
    "href": "profile.html#répertoire-temporaire",
    "title": "Principe",
    "section": "Répertoire temporaire",
    "text": "Répertoire temporaire\nWarning: multi utilisation d’un programme\n\ncd \"D:\\D\\stata_temp\\\"\n\n\nnoisily display as txt    \"------------------------------------\"\nnoisily display as result \"  Contenu du repertoire stata_temp  \"\nnoisily display as txt    \"------------------------------------\"\nnoisily dir \"D:/D/stata_temp/\"\n\nWarning pour ce qui suit: multi utilisateurs d’un programme\n\nglobal tmp \"D:/D/stata_temp/\""
  },
  {
    "objectID": "profile.html#log-automatique",
    "href": "profile.html#log-automatique",
    "title": "Principe",
    "section": "Log automatique",
    "text": "Log automatique\nLa plus utile de toutes les configurations décrites ici.\nAu préalable, je conseille de créer un répertoire d’enregistrement pour ces fichiers logs. Je les enregistre dans un sous répertoire de stat_temp appelé tout simplement log.\n[image]\n\ncapture log close statalog\nlocal cdt = \"`c(current_date)'\"\nlocal cdt: subinstr local cdt \" \" \"-\", all\nlocal cti = \"`c(current_time)'\"\nlocal cti: subinstr local cti \":\" \".\", all\nlocal statalogname \"statalog_`cdt'_`cti'.log\"\n\nlog using \"$user/log/`statalogname'\" , text name(statalog)"
  },
  {
    "objectID": "profile.html#commandes-de-type-set",
    "href": "profile.html#commandes-de-type-set",
    "title": "Principe",
    "section": "Commandes de type set",
    "text": "Commandes de type set\nRemarque: les commandes dédiées à Python\n\n\nIl n’est pas nécessaire d’ajouter l’option permanently comme le fichier profile est chargé à chaque ouverture de session.\nEnsemble des commandes de type set: help set\n\n\nExemple: nombre de décimales reportées dans l’output d’une régression avec set cformats (coef, se et bornes ci), set sformats (statistique du test) et set pformats (p-value) .\nSi on souhaite fixer le nombre de décimale pour l’ensemble des statistiques à 2\n\nset cformats %9.2f   // max longueur =9\nset sformats %9.2f   // max longueur =8\nset pformats %9.2f   // max longueur =5"
  },
  {
    "objectID": "profile.html#graphiques",
    "href": "profile.html#graphiques",
    "title": "Principe",
    "section": "Graphiques",
    "text": "Graphiques"
  },
  {
    "objectID": "speedup/gtools.html",
    "href": "speedup/gtools.html",
    "title": "Gtools",
    "section": "",
    "text": "gquantiles\ngreshape wide/long\ngcollapse\ngegen\nglevelsof\n\n\nGTOOLS\nAuteur: Mauricio Caceres Bravo\nInstallation:\n\nhttps://gtools.readthedocs.io/en/latest/index.html\nhttps://github.com/mcaceresb/stata-gtools\n\nLes Benchmarks réalisés par l’auteur ont été exécutés avec Stata MP. J’ai fait tourné son programme (lien) avec Stata 17 SE sous windows. Les résultats sont les suivants:\n\n     Versus | Native | gtools | % faster \n ---------- | ------ | ------ | -------- \n   collapse |   1.53 |   1.25 |   18.51% \n   collapse |   1.68 |   1.17 |   29.91% \n    reshape |  31.63 |   6.90 |   78.19% \n    reshape |  60.26 |  10.95 |   81.83% \n      xtile |  17.74 |   1.12 |   93.67% \n     pctile |  18.20 |   0.77 |   95.76% \n       egen |   2.13 |   0.64 |   69.77% \n   contract |   4.52 |   1.74 |   61.54% \n       isid |  18.71 |   0.68 |   96.35% \n duplicates |  10.07 |   0.86 |   91.42% \n   levelsof |   2.75 |   0.44 |   83.94% \n   distinct |   7.24 |   0.44 |   93.88% \n     winsor |  16.09 |   0.65 |   95.99% \n sum_detail |  17.09 |   1.22 |   92.86% \n    tabstat |  11.18 |   0.67 |   94.03% \n range_stat |  67.37 |   2.82 |   95.81% \n\nPour mon propre benchmark, plus gourmand (10 variables quanti et une variable binaire), les données sont générées de la manière suivante:\nCréation de la base de données (N=10M)\n\nclear \nset obs 10000000\ntempvar x\ngen `x' = runiform()\ngen g = `x'>.5\n\nforv i=1/10 {\ngen y`i' = rnormal()    \n    \ngen id = _n \n}\n\nPour récupérer les durées d’exécution, j’utilise un fragment du programme de M.Caceres. Les commandes sont exécutées avec le prefixe bench 1:\n\ncapture program drop bench\nprogram bench\n    gettoken timer call: 0,    p(:)\n    gettoken colon call: call, p(:)\n    cap timer clear `timer'\n    timer on `timer'\n    `call'\n    timer off `timer'\n    qui timer list\n    c_local r`timer' `=r(t`timer')'\nend\n\n\nLes tests sont réalisés avec les équivalents de xtile, reshape, collapseet levelsof. L’équivalent à tabstat sera ajouté rapidement.\nPour information, les programmes des fonctions R sont également rapidement décris. Les durées d’exécution ont été récupérés avec la librairie tictoc.\n\n\n\ngquantiles\n\nCommande usine xtile et pctile (help xtile). Le benchmark est seulement effectué pour xtile (affectation d’un quantile à une valeur) qui est plus gourmant que pctile (calcul et report des quantiles).\nEn termes d’options, l’autre intérêt de gquantile est de stratifier l’opération avec l’option by().\n\nSyntaxe courte\n\n*xtile\ngquantiles nouvelle_var = var1 , xtile  nq(#) [by(var2)]\n\n*pctile\ngquantiles nouvelle_var = var1 , pctile nq(#) [by(var2)] \n\nProgramme\n\n* Fonction bench (voir plus haut)\n\nqui forv i=1/10 {\n  \n** XTILE\n  \ntempvar yg`i'\nbench 1:   xtile `yg`i'' = y`i' ,  nq(10) \nlocal rt1 = `rt1' + `r1' \n  }\ndi \"XTILE runtime =\" `rt1'\n\n*** GQUANTILES\nqui forv i=1/10 {\ncapt drop  `yg`i''  \ntempvar yg`i'\nbench 1: gquantiles `yg`i'' = y`i' , xtile  nq(10) \nlocal rt2 = `rt2' + `r1'     \n   }\ndi  \"GQUANTILES runtime =\" `rt2'\n\nRésultats (secondes)\n\n\n\nStata\n10k\n100k\n1M\n10M\n\n\n\n\nxtile\n0.12\n1.65\n16.03\n196.56\n\n\ngquantiles\n0.06\n0.22\n1.24\n14.75\n\n\n\n\n\n\nR\n10k\n100k\n1M\n10M\n\n\n\n\nquantcut\n0.04\n0.24\n2.38\n29.11\n\n\nntile\n0.06\n0.16\n1.54\n15.51\n\n\n\n\n\n\n\n\n\nFonctions R\n\n\n\n\nquantcut\n\nlibrairie gtools\nSyntaxe pour la variable y1: df$gy1=quantcut(df$y1,10)\n\nntile\n\nlibrairie dplyr\nSyntaxe pour la variable y1: df=df %>% mutate(gy1 = ntile(y1, 10))\n\n\n\n\n\n\ngreshape\n\nNiveau syntaxe peu de différence avec la commande usine, si ce n’est pour les arguments i() et j()\n\ni() = id()\nj() = key()\n\nPour R:\n\nFonction de base reshape.\n\nAvantage: syntaxe très proche de Stata\nInconvénients: temps d’exécution pas optimal. Pour 10M d’observations, j’ai arrêté l’exécution au bout de 10 minutes.\n\nFonctions pivot_longer et pivot_wider de **tydir.\n\n\nSi greshape est nettement plus performant que reshape, il reste nettement en deçà des deux fonctions de la librairie tydir de R.\nProgramme\n\n* Fonction bench (voir plus haut)\n\n**RESHAPE\nqui bench 1: reshape long y, i(id) j(j)\ndi \"RESHAPE LONG runtime =\" `r1'\nqui bench 1: reshape wide y, i(id) j(j)\ndi \"RESHAPE WIDE runtime =\" `r1'\n\n**GRESHAPE\nqui bench 1: greshape long y, by(id) keys(j)\ndi \"GRESHAPE LONG runtime =\" `r1'\nqui bench 1: greshape wide y, by(id) keys(j)\ndi \"GRESHAPE WIDE runtime =\" `r1'\n\nRésultats (secondes)\n\nLongWide\n\n\n\n\n\nStata\n10K\n100k\n1M\n10M\n\n\n\n\nreshape long\n0.14\n1.22\n12.36\n245.18\n\n\ngreshape long\n0.04\n0.21\n3.22\n61.23\n\n\n\n\n\n\nR\n10k\n100k\n1M\n10M\n\n\n\n\nreshape\n0.1\n1.19\n11.9\n///\n\n\npivot_longer\n0.01\n0.12\n0.6\n13.39\n\n\n\n\n\n\n\n\nStata\n10k\n100k\n1M\n10M\n\n\n\n\nreshape wide\n0.37\n2.18\n26.58\n338.10\n\n\ngreshape wide\n0.06\n0.30\n2.79\n55.86\n\n\n\n\n\n\nR\n10k\n100k\n1M\n10M\n\n\n\n\nreshape\n0.37\n3.69\n34.93\n///\n\n\npivot_wider\n0.01\n0.24\n1.98\n38.97\n\n\n\n\n\n\n\n\n\n\n\n\nFonctions R\n\n\n\n\nreshape\n\nInstallé avec R\nLong: long = reshape(gtools, idvar = \"id\", timevar=\"j\", varying = list(2:11), v.names = \"y\", direction = \"long\")\nWide: wide = reshape(long, idvar = \"id\",  timevar=\"j\",  v.names = \"y\", sep = \"\", direction = \"wide\")\n\npivot_longer/pivot_wider\n\nlibrairie tydir\nlong: long = pivot_longer(gtools, cols = starts_with(\"y\"))\nwide: wide = pivot_wider(long, names_from = c(\"name\"), values_from = c(\"value\"))\n\n\n\n\n\n\ngcollapse\n\nSyntaxe identique à celle de collapse. Par défaut, c’est également la moyenne qui est calculée.\nAjout d’une option merge replace qui remplace la valeur des observations par l’indicateur séléctionné.\nOn ajouté l’option by() sur la variable g (deux groupes).\n\nProgramme\n\n*** COLLAPSE\npreserve\nqui bench 1: collapse  y1-y10,  by(g)\nlocal col `r1'\nrestore\n\n*** GCOLLAPSE\npreserve\nqui bench 1: gcollapse  y1-y10,  by(g)\nlocal gcol `r1' \nrestore\n\ndi \"N=`N\"\ndi \"COLLAPSEruntime =\" `col'\ndi \"GCOLLAPSEruntime =\" `gcol'\n\nRésultats (secondes)\n\n\n\nStata\n10K\n100K\n1M\n10 M\n\n\n\n\ncollapse\n0.007\n0.041\n0.461\n7.846\n\n\ngcollapse\n0.021\n0.049\n0.219\n2.559\n\n\nR\n10K\n100K\n1M\n10 M\n\n\nsummarise\n0.03\n0.06\n0.3\n1.91\n\n\n\nNote: pour Stata le programme exécute preserve/restore, ce qui augmente légèrement un temps d’exécution\n\n\n\n\n\n\nFonction R\n\n\n\n\nsummarise()\n\nlibrairie dplyr\nSyntaxe : collapse= gtools %>%  group_by(g) %>%  summarise(across(y1:y10, ~ mean(.x, na.rm = TRUE)))\n\n\n\n\nProgramme\n\n\ngegen\n\nSyntaxe identique à celle d’egen. On a choisi comme fonction la moyenne.\nOn ajouté l’option by() sur la variable g (deux groupes).\n\n\nforv  i=1/10 {\nqui bench 1: egen my`i' = mean(y`i'), by(g)\nlocal egen = `egen' + `r1' \n}\n\ndrop my*\n\nforv  i=1/10 {\nqui bench 1: gegen my`i' = mean(y`i'), by(g)\nlocal gegen = `gegen' + `r1' \n}\n\ndi \"N=`N\"\ndi \"EGEN  runtime =\" `egen'\ndi \"GEGEN runtime =\" `gegen'\n\n\n\n\nStata\n10k\n100k\n1M\n10M\n\n\n\n\negen\n0.23\n0.41\n4.82\n73.6\n\n\ngegen\n0.69\n0.20\n0.83\n8.88\n\n\nR\n10k\n100k\n1M\n10M\n\n\nmutate + mean\n0.03\n0.05\n0.17\n1.74\n\n\n\n\n\n\n\n\n\nFonction R\n\n\n\n\nmutate() associée à la fonction mean\n\nlibrairie dplyr\nSyntaxe :\n\nvar <- c(\"y1\", \"y2\", \"y3\", \"y4\", \"y5\", \"y6\", \"y7\", \"y8\", \"y9\", \"y10\")\ngtools = gtools %>% group_by(g) %>% mutate(across(var, mean, .names = \"m{col}\"))\n\n\n\n\n\n\n\nglevelsof\n\n\n\n\n\n\nRappel\n\n\n\n\nLa commande levelsof (help levelsof) permet de récupérer automatiquement les valeurs d’une variable pour les transformer sous forme de macro. Par défaut la macro enregistrée est nommée r(levels), il est possible de l’appeler différemment avec l’option local(). Elle est particulièrement utile en amont d’une opération en boucle de type foreach. La macro générée r(r) permet de récupérer le nombre de valeurs enregistrés, et peut donc être utile pour des instructions en boucle de type forvalue (et évite de programmer une macro avec la fonction word count plus loin).\nLes valeurs sont enregistrées par ordre croissant numérique ou alphabétique selon le type de variable.\n\n\n\nglevelsof\n\nAutorise plusieurs variables. la macro enregistrée concaténera les valeurs et/ou expression avec un séparateur (espace par défaut).\nPermet de trier les valeurs en ordre décroissant en ajoutant - devant le nom de la variable.\n\nbenchmark\n\nBien évidemment, pas de comparaison possible avec R\nProgramme d’origine différent: on va générer une variable qui affecte aléatoirement une lettre de l’alphabet (une version caractère et une version numérique générée avec encode). Le programme a été écrit par Paul Picard sur le forum Statalist (lien)\n\n\nclear\nset obs 10000\nlocal c2use ABCDEFGHIJKLMNPQRSTUVWXYZ\ngen random_string = substr(\"`c2use'\", runiformint(1,length(\"`c2use'\")),1) + ///\n    string(runiformint(0,9)) + ///\n    char(runiformint(65,90)) + ///\n    char(runiformint(65,90)) + ///\n    string(runiformint(0,9)) + ///\n    char(runiformint(65,90))\n\ngen xchar = substr(random_string,1,1)\nencode xchar, gen(xnum)\ndrop random_string\n\nLevelsof :\n\nlevelsof xchar\n\n/*\n`\"A\"' `\"B\"' `\"C\"' `\"D\"' `\"E\"' `\"F\"' `\"G\"' `\"H\"' `\"I\"' `\"J\"' `\"K\"' `\"L\"' `\"M\"' `\"N\"' `\"P\"' `\"Q\"' `\n> \"R\"' `\"S\"' `\"T\"' `\"U\"' `\"V\"' `\"W\"' `\"X\"' `\"Y\"' `\"Z\"'\n*/\n\nlevelsof xnum\n\n/*\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n*/\n\nGlevelsof avec valeurs enregistrées en ordre décroissant:\n\nglevelsof -xchar\n\n`\"Z\"' `\"Y\"' `\"X\"' `\"W\"' `\"V\"' `\"U\"' `\"T\"' `\"S\"' `\"R\"' `\"Q\"' `\"P\"' `\"N\"' `\"M\"' `\"L\"' `\"K\"' `\"J\"' \n` \"I\"' `\"H\"' `\"G\"' `\"F\"' `\"E\"' `\"D\"' `\"C\"' `\"B\"' `\"A\"'\n\nglevelsof -xnum\n\n25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\n\n\n\n\nVariable caractère\n10k\n100k\n1M\n10M\n\n\n\n\nlevelsof\n0.01\n0.10\n2.64\n42.51\n\n\nglevelsof\n0.01\n0.01\n0.11\n0.62\n\n\n\n\n\n\nVariable numerique\n10k\n100k\n1M\n10M\n\n\n\n\nlevelsof\n0.01\n0.01\n0.09\n1.04\n\n\nglevelsof\n0.00\n0.01\n0.04\n0.32"
  },
  {
    "objectID": "speedup/intro.html",
    "href": "speedup/intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Stata 17: grosse amélioration du temps d’exécution de certaines commandes, en particulier sort et collapse.\nDepuis de nombreuses années des packages ou commandes standalone amélioraientt le temps d’exécution, en particulier les packages ftools de Sergio Correa ou les commandes fastxtile/fastwpctile d’egenmisc.\nLe package gtools de Mauricio Caceres Bravo donne des résultats vraiment très intéressants lorsqu’on atteint un seuil d’un million d’observations pour les commandes suivantes: greshape, gquantiles, gegen, glevelof avec une variable caractère, et dans une moindre mesure gcollapse.\nAu delà des durées d’exécution, ces packages et commandes peuvent avoir quelques options propres, par exemple, l’option by() de gquantiles ou la possibilité d’enregistrer les valeurs en ordre décroissant avec glevelsof.\n\nBenchmarks\n\nVersion Stata 17 SE. Les benchmarks réalisés par Mauricio Caceres sont en version MP.\nConfiguration PC: i5-10210U CPU et 16GO de RAM.\nVolumétries: 10k, 100k, 1M, 10M.\nComparaisons avec R si fonctions équivalentes.\nProgramme Stata: https://github.com/mthevenin/stata_programmation/blob/main/speedup/benchmark.do\nTo do: faire les tests sur la version serveur-linux (toujours Stata 17 SE)\n\nSources:\n\nStata 17 faster: https://www.stata.com/new-in-stata/faster-stata-speed-improvements/\nftools: https://github.com/sergiocorreia/ftools\ngtools:\n\nhttps://gtools.readthedocs.io/en/latest/index.html\nhttps://github.com/mcaceresb/stata-gtools"
  }
]